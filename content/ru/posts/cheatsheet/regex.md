---
Название: RegEX
дата: 2020-11-25 18:28:43
фон: bg-[#e56d2d]
теги:
    - регулярное выражение
    - регексп
    - шаблон
категории:
    - Инструментарий
intro: |
    Краткое руководство по регулярным выражениям (regex), включающее символы, диапазоны, группировку, утверждения и несколько примеров шаблонов для начала работы.
плагины:
    - copyCode
---

Начало работы
--------

### Введение

Это краткая шпаргалка по началу работы с регулярными выражениями.

- [Regex в Python](#regex-in-python) _(cheatsheets.zip)_
- [Regex в JavaScript](#regex-in-javascript) _(cheatsheets.zip)_
- [Regex в PHP](#regex-in-php) _(cheatsheets.zip)_
- [Regex в Java](#regex-in-java) _(cheatsheets.zip)_
- [Regex в MySQL](#regex-in-mysql) _(cheatsheets.zip)_
- [Regex в Vim](/vim#search-and-replace) _(cheatsheets.zip)_
- [Regex в Emacs](/emacs#search) _(cheatsheets.zip)_
- [Online regex tester](https://regex101.com/) _(regex101.com)_
{.cols-2 .marker-round}

### Классы символов

| Шаблон | Описание |
|---------------|-----------------------------------------------|
| `[abc]` | Одиночный символ из: a, b или c |
| `[^abc]` | Символ, за исключением: a, b или c |
| `[a-z]` | Символ в диапазоне: a-z |
| `[^a-z]` | Символ, не входящий в диапазон: a-z |
| `[0-9]` | Цифра в диапазоне: 0-9 |
| `[a-zA-Z]` | Символ в диапазоне:<br>a-z или A-Z |
| `[a-zA-Z0-9]` | Символ в диапазоне: <br>a-z, A-Z или 0-9 |


### Квантификаторы

| Шаблон | Описание |
|---------|-------------------|
| `a?` | Ноль или один из |
| | `a*` | Ноль или больше из a |
| `a+` | Одно или более |

|`[0-9]+`` | Одно или более из 0-9|

|`a{3}` | Ровно 3 из a|
|`a{3,}` | 3 или более a|
|`a{3,6}` | От 3 до 6 a|

|`a*` | Жадный квантификатор|
|`a*`` | Ленивый квантификатор|
|`a*+` | Possessive quantifier|





### Общие метасимволы

- \^
- \{
- \+
- \<
- \[
- \*
- \)
- \>
- \.
- \(
- \|
- \$
- \\
- \?
{.cols-3 .marker-none}

Экранируйте эти специальные символы с помощью `\`






### Метапоследовательности {.row-span-4}

| Pattern | Description |
|--------------|-------------------------------------------------------------|
| `.` | Любой одиночный символ |
| `\s` | Любой пробельный символ |
| `\S` | Любой символ, не являющийся пробельным |
| `\d` | Любая цифра, такая же, как [0-9]|
| `\D` | Любая нецифровая цифра, такая же, как [^0-9] |
| `\w` | Любой символ слова |
| `\W` | Любой несловарный символ |
| `\X` | Любые последовательности Unicode, включая символы перевода строки |
| `\C` | Соответствие одной единице данных |
| `\R` | Новые строки Юникода |
| `\v` | Вертикальный символ пробела |
| `\V` | Отрицание \v - все, кроме новых строк и вертикальных табуляций |
| `\h` | Горизонтальный символ пробельного символа |
| `\H` | Отрицание \h |
| `\K` | Сброс совпадения |
| `\n` | Соответствие n-му подшаблону |
| `\pX` | Свойство Юникода X |
| `\p{...}` | Свойство Unicode или категория сценария |
| `\PX` | Отрицание \pX |
| `\P{...}` | Отрицание \p |
| `\Q...\E` | Цитата; рассматривать как литерал |
| `\k<name>` | Соответствие подшаблону `name` |
| `\k'name'` | Искать подшаблон `name'|
| | `\k{name}` | Соответствовать подшаблону `name` |
| | `\gn` | Соответствие n-му подшаблону |
| `\g{n}` | Соответствие n-му подшаблону |
| `\g<n>` | Перебор n-ой группы захвата |
| `\g'n'` | Перебор n-й группы захватов.                                 |
| `\g{-n}` | Соответствие n-му относительному предыдущему подшаблону |
| `\g<+n>` | Перебор n-го относительного последующего подшаблона |
| | `\g'+n'` | Соответствие n-му относительному предыдущему подшаблону |
| | `\g'letter'` | Recurse named capture group `letter` |
| | `\g{letter}` | Искать ранее названную группу захвата `letter` |
| `\g<letter>` | Рекурсия именованной группы захвата `letter` |
| `\xYY` | Шестнадцатеричный символ YY |
| `\x{YYY}` | Шестнадцатеричный символ YYYY |
| `\ddd` | Октальный символ ddd |
| `\cY` | Управляющий символ Y |
| | `[\b]` | Символ обратного пробела |
| `\` | Делает любой символ литералом |




### Якоря

| Шаблон | Описание |
|---------|------------------------|
| `\G` | Начало совпадения |
| `^` | Начало строки |
| | `$` | Конец строки |
| `\A` | Начало строки |
| `\Z` | Конец строки |
| `\z` | Абсолютный конец строки |
| `\b` | Граница слова |
| `\B` | Граница неслова |




### Подстановка

| Pattern | Description |
|------------|---------------------------------|
| `\0` | Содержимое полного совпадения |
| `\1` | Содержимое в группе захвата 1 |
| `$1` | Содержимое группы захвата 1 |
| `${foo}` | Содержимое группы захвата `foo` |
| `\x20` | Шестнадцатеричные значения замены |
| `\x{06fa}` | Шестнадцатеричные значения замены |
| `\t` | Табуляция |
| `\r` | Возврат каретки |
| `\n` | Новая строка |
| `\f` | Form-feed |
| `\U` | Преобразование прописных букв |
| `\L` | Преобразование нижнего регистра |
| `\E` | Прервать любое преобразование |




### Групповые конструкции

| Pattern | Description |
|-----------|-----------------------------------|
| `(...)` | Захватывать все, что заключено |
| `(a|b)` | Искать либо a, либо b |
| `(?:...)` | Искать все, что вложено |
| `(?>...)` | Атомарная группа (не захватывающая)|
| | `(?|...)` | Номер дублирующей группы подшаблонов |
| `(?#...)` | Комментарий |

|`(?'name'...)` | Именованная группа захвата|
|`(?<name>...)` | Named Capturing Group|
|`(?P<имя>...)` | Именованная группа захвата|

|`(?imsxXU)` | Встроенные модификаторы|
|`(?(DEFINE)...)` | Предварительное определение шаблонов перед их использованием|



### Утверждения


| - | - |
|---------------------|---------------------------------|
| `(?(1)да|нет)` | Условное утверждение |
| `(?(R)yes|no)` | Условный оператор |
| `(?(R#)yes|no)` | Рекурсивный условный оператор |
| `(?(R&name)yes|no)` | Условный оператор |
| `(?(?=...)yes|no)` | Условный оператор с задержкой на будущее |
| `(?(?<=...)yes|no)` | Lookbehind conditional |



### Lookarounds

| - | - |
|------------|---------------------|
| `(?=...)` | Positive Lookahead |
| `(?!...)` | Отрицательный заголовок |
| | `(?<=...)` | Positive Lookbehind |
| | `(?<!...)` | Negative Lookbehind |
Lookaround позволяет сопоставить группу до (lookbehind) или после (lookahead) основного шаблона, не включая ее в результат.




### Флаги/модификаторы

| Шаблон | Описание |
|---------|-----------------------|
| `g` | Глобальный |
| `m` | Многострочный |
| `i` | Нечувствительный к регистру |
| `x` | Игнорировать пробельные символы |
| `S` | Однострочный |
| `u` | Юникод |
| `X` | eXtended |
| `U` | Неграмотный |
| `A` | Якорь |
| `J` | Дублирование имен групп |



### Recurse

| - | - |
|-------------|-----------------------------------|
| `(?R)` | Вывод всего образца |
| `(?1)` | Вывод первого подшаблона |
| `(?+1)` | Вывод первого относительного подшаблона |
| | `(?&name)` | Вывод подшаблона `name` |
| | `(?P=name)` | Match subpattern `name` |
| | `(?P>name)` | Recurse subpattern `name` |




### Классы символов POSIX {.col-span-2}
| Класс символов | То же, что | Значение |
|-----------------|-------------------------|--------------------------------|
| `[[:alnum:]]` | `[0-9A-Za-z]` | Буквы и цифры |
| `[[:alpha:]]` | `[A-Za-z]` | Буквы |
| `[[:ascii:]]` | `[\x00-\x7F]` | ASCII-коды 0-127 |
| | `[[:blank:]]` | `[\t ]` | Только пробел или табуляция |
| | `[[:cntrl:]]` | `[\x00-\x1F\x7F]` | Управляющие символы |
| | `[[:digit:]]` | `[0-9]` | Десятичные цифры |
| | `[[:graph:]]` | `[[:alnum:][:punct:]]` | Видимые символы (не пробел) |
| | `[[:lower:]]` | `[a-z]` | Строчные буквы |
| | `[[:print:]]` | `[ -~] == [:graph:]]` | Видимые символы |
| | `[[:punct:]]` | <code>[!"#$%&'()*+,-./:;<=>?@[]^_\`{\|}~]</code> | Видимые знаки пунктуации |
| `[[:пробел:]]` | <code>[\t\n\v\f\r ]</code> | Пробел |
| | `[[:upper:]]` | `[A-Z]` | Прописные буквы |
| | `[[:word:]]` | `[0-9A-Za-z_]` | Словесные символы |
| `[[:xdigit:]]` | `[0-9A-Fa-f]` | Шестнадцатеричные цифры |
| | `[[:<:]]` | `[\b(?=\w)]` | Начало слова |
| | `[[:>:]]` | `[\b(?<=\w)]` | Конец слова |
{.show-header}





### Управляющий глагол

| - | - |
|------------------------|-----------------------|
| `(*ACCEPT)` | Глагол управления |
| `(*FAIL)` | Управляющий глагол |
| `(*MARK:NAME)` | Глагол управления |
| `(*COMMIT)` | Глагол управления |
| `(*PRUNE)` | Глагол управления |
| `(*SKIP)` | Управляющий глагол |
| `(*THEN)` | Управляющий глагол |
| `(*UTF)` | Модификатор шаблона |
| `(*UTF8)` | Модификатор шаблона |
| `(*UTF16)` | Модификатор шаблона |
| | `(*UTF32)` | Модификатор шаблона |
| | `(*UCP)` | Модификатор шаблона |
| | `(*CR)` | Модификатор переноса строки |
| `(*LF)` | Модификатор переноса строки |
| `(*CRLF)` | Модификатор переноса строки |
| `(*ANYCRLF)` | Модификатор переноса строки |
| | `(*ANY)` | Модификатор перевода строки |
| `\R` | Модификатор перевода строки |
| `(*BSR_ANYCRLF)` | Модификатор переноса строки |
| `(*BSR_UNICODE)` | Модификатор перевода строки |
| `(*LIMIT_MATCH=x)` | Модификатор регекса |
| `(*LIMIT_RECURSION=d)` | Модификатор регекса |
| | `(*NO_AUTO_POSSESS)` | Модификатор Regex-движка |
| `(*NO_START_OPT)` | Модификатор Regex-движка |





Примеры Regex{.cols-3}
--------------

### Characters
| Pattern | Matches |
|----------------|------------------------------------------------------------|
| `ring` | Match <yel>ring</yel> sp<yel>ring</yel>board etc.          |
| `.           ` | Искать <yel>a</yel>, <yel>9</yel>, <yel>+</yel> и т.д.      |
| | `h.o` | Искать <yel>hoo</yel>, <yel>h2o</yel>, <yel>h/o</yel> и т.д. |
| `ring\?      ` | Искать <yel>кольцо?</yel> |
| `\(тихий\) ` | Соответствие <yel>(тихий)</yel> |
| `c:\\windows` | Искать <yel>c:\windows</yel> |

Используйте `\` для поиска этих специальных символов: <br> `[ \ ^ $ . | ? * + ( ) { }`


### Альтернативы

| Pattern | Matches |
|----------------|--------------------------------------------|
| `cat|dog` | Искать <yel>cat</yel> или <yel>dog</yel> |
| `id|identity` | Искать <yel>id</yel> или <yel>id</yel>entity |
| | `identity|id` | Искать <yel>id</yel> или <yel>identity</yel> |

Упорядочивание от более длинного к более короткому, когда альтернативы пересекаются

### Классы символов
| Pattern | Matches |
|-------------------|--------------------------------------------------------------------|
| `[aeiou]` | Искать любую гласную |
| `[^aeiou]` | Соответствует НЕ гласной |
| `r[iau]ng` | Соответствует <yel>ring</yel>, w<yel>rang</yel>le, sp<yel>rung</yel> и т.д. |
| `gr[ae]y` | Искать <yel>gray</yel> или <yel>grey</yel> |
| | `[a-zA-Z0-9]` | Искать любую букву или цифру |
| `[\u3a00-\ufa99]` | Искать любую [Unicode Hàn (中文)](https://unicode.org/charts/unihan.html) |

В `[ ]` всегда экранируется `. \ ]` и иногда `^ - .`


### Классы сокращений
| Pattern | Meaning |
|------------------|-------------------------------------------------------|
| `\w` | "Слово" символ <br>_(буква, цифра или знак подчеркивания)_ |
| `\d ` | Цифра |
| | `\s ` | Пробел <br>_(пробел, табуляция, vtab, новая строка)_ |
| `\W, \D или \S ` | Не слово, не цифра и не пробел |
| `[\D\S] ` | Означает не цифру и не пробел, оба совпадают |
| `[^\d\s] ` | Запретить цифру и пробел |


### Occurrences
| Pattern | Matches |
|---------------------|--------------------------------------------------------------------|
| `colou?r` | Искать <yel>color</yel> или <yel>colour</yel> |
| `[BW]ill[ieamy's]*` | Искать <yel>Bill</yel>, <yel>Willy</yel>, <yel>William's</yel> и т.д. |
| `[a-zA-Z]+` | Искать 1 или более букв |
| `\d{3}-\d{2}-\d{4}` | Соответствие SSN |
| `[a-z]\w{1,7}` | Соответствие идентификатору UW NetID |



### Жадность против лени
| Шаблон | Значение |
|--------------------------|---------------------------------------------------------|
| `* + {n,}`<br>_greedy_ | Искать как можно больше совпадений |
| `<.+>` | Находит 1 большое совпадение в <yel>\<b>bold\<\/b></yel> |
| `*?  +? {n,}?`<br>_lazy_ | Находит как можно меньше совпадений | |
| `<.+?>` | Находит 2 совпадения в \<<yel>b</yel>>bold\<<yel>\/b</yel>> |


### Область {.col-span-2}
| Pattern | Meaning |
|--------------------|--------------------------------------------------------|
| `\b` | Край "слова" (рядом с символом, не являющимся "словом")|
| `\bring ` | Слово начинается с "ring", например <yel>ringtone</yel> |
| `\b9\b` | Слово заканчивается на "ring", например <yel>spring</yel> |
| | `\b9\b` | Искать одиночную цифру <yel>9</yel>, а не 19, 91, 99 и т.д. |
| `\b[a-zA-Z]{6}\b ` | Искать слова из 6 букв |
| | `\B ` | Не край слова |
| | `\Bring\B` | Сопоставлять <yel>пружины</yel> и <yel>пружины</yel> |
| `^\d*$ ` | Вся строка должна состоять из цифр |
| `^[a-zA-Z]{4,20}$` | Строка должна содержать 4-20 букв |
| `^[A-Z] ` | Строка должна начинаться с заглавной буквы |
| `[\.!?"')]$ ` | Строка должна заканчиваться терминальной пунктуацией |



### Модификаторы
| Шаблон | Значение |
|---------------------|----------------------------------------------------------|
| `(?i)`[a-z]*`(?-i)` | Игнорировать регистр ON / OFF |
| `(?s)`.*`(?-s)` | Соответствие нескольким строкам (заставляет . соответствовать новой строке) |
| | `(?m)`^.*;$`(?-m)` | <yel>^</yel> & <yel>$</yel> соответствуют строкам, а не всей строке |
| | `(?x)` | # режим свободного интервала, этот комментарий EOL игнорируется |
| | `(?-x)` | Режим свободного интервала выключен |
| /regex/`ismx` | Изменить режим для всей строки |



### Группы
| Pattern | Meaning |
|------------------|---------------------------------------------|
| `(in\|out)put` | Соответствие <yel>входу</yel> или <yel>выходу</yel> |
| `\d{5}(-\d{4})?` | Почтовый индекс США _("+ 4" необязательно)_ |
Парсер пробует КАЖДУЮ альтернативу, если совпадение не удалось после группы.
<br>
Это может привести к катастрофическому откату назад.




### Обратные ссылки
| Pattern | Matches |
|--------------------------|-----------------------------------------------------------------------------|
| `(to) (be) or not \1 \2` | Соответствие <yel>to be or not to be</yel> |
| `([^\s])\1{2}` | Искать без пробела, затем то же самое еще два раза &nbsp; <yel>aaa</yel>, <yel>...</yel> |
| `\b(\w+)\s+\1\b` | Искать удвоенные слова |



### Группа не захвата
| Образец | Значение |
|---------------------|------------------------------------|
| `on(?:click\|load)` | Быстрее, чем: <br>`on(click\|load)` |

По возможности используйте незахватывающие или атомарные группы



### Атомарные группы
| Шаблон | Значение |
|------------------------|--------------------------------------------------|
| `(?>red\|green\|blue)\b` | Быстрее, чем без захвата |
| `(?>id\|identity)\b` | Совпадает с <yel>id</yel>, но не с <yel>id</yel>entity |

"id" совпадает, но `\b` не работает после атомарной группы,
синтаксический анализатор не возвращается в группу для повторной попытки определения 'identity'
<br>
<br>
Если альтернативы пересекаются, упорядочиваем более длинные к более коротким.



### Lookaround {.row-span-2 .col-span-2}
| Pattern | Meaning |
|-------------------------|-----------------------------------------------------------------------|
| `(?= )` | Lookahead, если вы можете найти впереди |
| `(?! )` | Lookahead, если вы не можете найти впереди |
| `(?<= )` | Lookbehind, если вы можете найти позади |
| `(?<! )` | Lookbehind, если вы НЕ можете найти позади |
| `\b\w+?(?=ing\b)` | Match <yel>warbl</yel>ing, <yel>str</yel>ing, <yel>fish</yel>ing, ... |
| `\b(?!\w+ing\b)\w+\b` | Слова, не оканчивающиеся на "ing" |
| `(?<=\bpre).*?\b` | Искать pre<yel>tend</yel>, pre<yel>sent</yel>, pre<yel>fix</yel>, ...  |
| `\b\w{3}(?<!pre)\w*?\b` | Слова, НЕ начинающиеся с "pre" |
| `\b\w+(?<!ing)\b` | Искать слова, не заканчивающиеся на "ing"|


### If-then-else
Искать "Mr." или "Ms.", если слово "her" находится позже в строке

```
M(?(?=.*?\bher\b)s|r)\.
```
требует поиска для условия IF


RegEx в Python
---------------

### Начало работы

Импортируйте модуль регулярных выражений

``python
import re
```


### Примеры {.col-span-2 .row-span-3}

#### re.search()
``python
>>> sentence = 'Это пример строки'
>>> bool(re.search(r'this', sentence, flags=re.I))
True
>>> bool(re.search(r'xyz', sentence))
False
```

#### re.findall()
``python
>>> re.findall(r'\bs?pare?\b', 'par spar apparent spare part pare')
['par', 'spar', 'spare', 'pare']
>>> re.findall(r'\b0*[1-9]\d{2,}\b', '0501 035 154 12 26 98234')
['0501', '154', '98234']
```


#### re.finditer()
``python
>>> m_iter = re.finditer(r'[0-9]+', '45 349 651 593 4 204')
>>> [m[0] for m in m_iter if int(m[0]) < 350]
['45', '349', '4', '204']
```


#### re.split()
``python
>>> re.split(r'\d+', 'Sample123string42with777numbers')
['Sample', 'string', 'with', 'numbers']
```


#### re.sub()
``python
>>> ip_lines = "catapults\nconcatenate\ncat"
>>> print(re.sub(r'^', r'* ', ip_lines, flags=re.M))
* catapults
* конкатенат
* cat
```

#### re.compile()
``python
>>> pet = re.compile(r'dog')
>>> type(pet)
<class '_sre.SRE_Pattern'>
>>> bool(pet.search('Они купили собаку'))
True
>>> bool(pet.search('Им дорогу перешла кошка'))
False
```

### Функции

| Функция | Описание |
|---------------|-------------------------------------------------------------------|
| `re.findall` | Возвращает список, содержащий все совпадения |
| | `re.finditer` | Возвращает итерабель объектов match (по одному на каждое совпадение) |
| | `re.search` | Возвращает объект Match, если в строке есть совпадение |
| `re.split` | Возвращает список, в котором строка была разделена на каждое совпадение |
| `re.sub` | Заменяет одно или несколько совпадений строкой |
| | `re.compile` | Компиляция шаблона регулярного выражения для последующего использования |
| `re.escape` | Возвращает строку, в которой все неалфавитно-цифровые символы отделены обратной косой чертой |



### Флаги


| - | - | - |
|--------|-----------------|----------------------------------------------|
| `re.I` | `re.IGNORECASE` | Игнорировать регистр |
| `re.M` | `re.MULTILINE` | Многострочный |
| `re.L` | `re.LOCALE` | Сделать `\w`,`\b`,`\s` _локально зависимыми_ |
| `re.S` | `re.DOTALL` | Точка совпадает со всеми _(включая новую строку)_ |
| | `re.U` | `re.UNICODE` | Сделать `\w`,`\b`,`\d`,`\s` _юникод-зависимыми_ |
| | `re.X` | `re.VERBOSE` | Стиль для чтения |



Regex в JavaScript
---------------

### test()
``javascript
let textA = 'Мне очень нравятся яблоки';
let textB = 'Мне нравятся яблоки';
let regex = /apples$/i
 
// Выход: false
console.log(regex.test(textA));
 
// Вывод: true
console.log(regex.test(textB));
```

### search()

```javascript
let text = 'Мне очень нравятся яблоки';
let regexA = /apples/;
let regexB = /apples/i;
 
// Выходные данные: -1
console.log(text.search(regexA));
 
// Вывод: 7
console.log(text.search(regexB));
```


### exec()

``javascript
let text = 'Вы любите яблоки?';
let regex = /apples/;
 
// Выходные данные: яблоки
console.log(regex.exec(text)[0]);
 
// Вывод: Вы любите яблоки?
console.log(regex.exec(text).input);
```


### match()

``javascript
let text = 'Здесь яблоки и апплС';
let regex = /apples/gi;
 
// Вывод: ["apples", "apPleS" ].
console.log(text.match(regex));
```




### split() {.col-span-2}

``javascript
let text = 'Эта 593 строка будет бро294ена в местах, где есть d1gits.';
let regex = /\d+/g
 
// Вывод: ["Эта ", " строка будет брошена", "en в местах, где есть d", "gits" ].
console.log(text.split(regex))
```



### matchAll()

``javascript
let regex = /t(e)(st(\d?))/g;
let text = 'test1test2';
let array = [...text.matchAll(regex)];

// Выходные данные: ["test1", "e", "st1", "1"].
console.log(array[0]);

// Выходные данные: ["test2", "e", "st2", "2"]
console.log(array[1]);
```



### replace()

``javascript {.wrap}
let text = 'Любите ли вы яблоки?';
let regex = /apples/i
 
// Вывод: Do you like mangoes?
let result = text.replace(regex, 'mangoes');
console.log(result);
```


### replaceAll()

```javascript
let regex = /apples/gi;
let text = 'Здесь яблоки и апплС';

// Вывод: Здесь манго и манго
let result = text.replaceAll(regex, "mangoes");
console.log(result);
```



Регекс в PHP
------------

### Функции {.col-span-2}


| - | - |
|---------------------------|------------------------------------------------------------------|
| `preg_match()` | Выполняет совпадение регулярных выражений |
| `preg_match_all()` | Выполняет глобальное совпадение регулярных выражений |
| `preg_replace_callback()` | Выполнить поиск и замену регулярного выражения с помощью обратного вызова |
| `preg_replace()` | Выполнить поиск и замену регулярного выражения |
| `preg_split()` | Разделяет строку по шаблону regex |
| `preg_grep()` | Возвращает записи массива, соответствующие шаблону |



### preg_replace
``php {.wrap}
$str = "Посетите Microsoft!";
$regex = "/microsoft/i";

// Вывод: Посетите CheatSheets!
echo preg_replace($regex, "CheatSheets", $str);
```



### preg_match
```php
$str = "Посетите CheatSheets";
$regex = "#cheatsheets#i";

// Вывод: 1
echo preg_match($regex, $str);
```



### preg_matchall {.col-span-2 .row-span-2}
```php
$regex = "/[a-zA-Z]+ (\d+)/";
$input_str = "24 июня, 13 августа и 30 декабря";
if (preg_match_all($regex, $input_str, $matches_out)) {

    // Выход: 2
    echo count($matches_out);

    // Вывод: 3
    echo count($matches_out[0]);

    // Выходные данные: Array("24 июня", "13 августа", "30 декабря")
    print_r($matches_out[0]);

    // Выходные данные: Array("24", "13", "30")
    print_r($matches_out[1]);
}
```



### preg_grep
``php
$arr = ["Jane", "jane", "Joan", "JANE"];
$regex = "/Jane/";

// Вывод: Джейн
echo preg_grep($regex, $arr);
```


### preg_split {.col-span-2}
``php
$str = "Jane\tKate\nLucy Marion";
$regex = "@\s@";

// Выходные данные: Array("Jane", "Kate", "Lucy", "Marion")
print_r(preg_split($regex, $str));
```


Регекс в Java
-------------


### Стили {.col-span-2}

#### Первый способ
``java
Pattern p = Pattern.compile(".s", Pattern.CASE_INSENSITIVE);
Matcher m = p.matcher("aS");
boolean s1 = m.matches();
System.out.println(s1); // Выходные данные: true
```

#### Второй способ
``java
boolean s2 = Pattern.compile("[0-9]+").matcher("123").matches();
System.out.println(s2); // Вывод: true
```

#### Третий способ
``java
boolean s3 = Pattern.matches(".s", "XXXX");
System.out.println(s3); // Вывод: false
```


### Поля шаблона


| - | - |
|--------------------|---------------------------------|
| `CANON_EQ` | Каноническая эквивалентность |
| `CASE_INSENSITIVE` | Сопоставление без учета регистра |
| `COMMENTS` | Разрешает пробельные символы и комментарии |
| `DOTALL` | Точечный режим |
| `MULTILINE` | Многострочный режим |
| `UNICODE_CASE` | Свертывание регистра с учетом юникода |
| `UNIX_LINES` | Режим строк Unix |





### Методы

#### Pattern
- Pattern compile(String regex [, int flags])
- boolean matches([String regex, ] CharSequence input)
- String[] split(String regex [, int limit])
- String quote(String s)

#### Matcher
- int start([int group | String name])
- int end([int group | String name])
- boolean find([int start])
- String group([int group | String name])
- Matcher reset()

#### String

- boolean matches(String regex)
- String replaceAll(String regex, String replacement)
- String[] split(String regex[, int limit])

Есть и другие методы ...




### Примеры {.col-span-2}

Замените предложение:
``java
String regex = "[A-Z\n]{5}$";
String str = "Мне нравится APP\nLE";

Pattern p = Pattern.compile(regex, Pattern.MULTILINE);
Matcher m = p.matcher(str);

// Выходные данные: Мне нравится Apple!
System.out.println(m.replaceAll("pple!"));
```

Массив всех совпадений:
``java
String str = "Она продает ракушки на берегу моря";
String regex = "\\w*se\\\w*";

Pattern p = Pattern.compile(regex, Pattern.CASE_INSENSITIVE);
Matcher m = p.matcher(str);

List<String> matches = new ArrayList<>();
while (m.find()) {
    matches.add(m.group());
}

// Выходные данные: [sells, seashells, Seashore].
System.out.println(matches);
```


Regex в MySQL {.cols-2}
-------------

### Функции
| Имя | Описание |
|--------------------|--------------------------------------------------------------------------|
| `REGEXP` | Совпадает ли строка с regex |
| `REGEXP_INSTR() ` | Начальный индекс подстроки, соответствующей regex <br>_(NOTE: Только MySQL 8.0+)_ |
| `REGEXP_LIKE() ` | Совпадает ли строка с regex <br>_(ПРИМЕЧАНИЕ: Только MySQL 8.0+)_ |
| `REGEXP_REPLACE()` | Замена подстрок, соответствующих regex <br>_(ПРИМЕЧАНИЕ: Только MySQL 8.0+)_ |
| `REGEXP_SUBSTR()` | Вернуть подстроку, соответствующую regex <br>_(ПРИМЕЧАНИЕ: Только MySQL 8.0+)_ |



### REGEXP
```sql {.wrap}
expr REGEXP pat
```
#### Примеры
```sql
mysql> SELECT 'abc' REGEXP '^[a-d]';
1
mysql> SELECT name FROM cities WHERE name REGEXP '^A';
mysql> SELECT name FROM cities WHERE name NOT REGEXP '^A';
mysql> SELECT name FROM cities WHERE name REGEXP 'A|B|R';
mysql> SELECT 'a' REGEXP 'A', 'a' REGEXP BINARY 'A';
1 0
```


### REGEXP_REPLACE
``` {.wrap}
REGEXP_REPLACE(expr, pat, repl[, pos[, occurrence[, match_type]]])
```
#### Примеры
```ql
mysql> SELECT REGEXP_REPLACE('a b c', 'b', 'X');
a X c
mysql> SELECT REGEXP_REPLACE('abc ghi', '[a-z]+', 'X', 1, 2);
abc X
```




### REGEXP_SUBSTR
``` {.wrap}
REGEXP_SUBSTR(expr, pat[, pos[, occurrence[, match_type]]])
```
#### Примеры
```ql
mysql> SELECT REGEXP_SUBSTR('abc def ghi', '[a-z]+');
abc
mysql> SELECT REGEXP_SUBSTR('abc def ghi', '[a-z]+', 1, 3);
ghi
```


### REGEXP_LIKE
```
REGEXP_LIKE(expr, pat[, match_type])
```
#### Примеры
```ql
mysql> SELECT regexp_like('aba', 'b+')
1
mysql> SELECT regexp_like('aba', 'b{2}')
0
mysql> # i: нечувствительно к регистру
mysql> SELECT regexp_like('Abba', 'ABBA', 'i');
1
mysql> # m: многострочный
mysql> SELECT regexp_like('a\nb\nc', '^b$', 'm');
1
```




### REGEXP_INSTR
``` {.wrap}
REGEXP_INSTR(expr, pat[, pos[, occurrence[, return_option[, match_type]]]])
```
#### Примеры
```ql
mysql> SELECT regexp_instr('aa aaa aaaa', 'a{3}');
2
mysql> SELECT regexp_instr('abba', 'b{2}', 2);
2
mysql> SELECT regexp_instr('abbabba', 'b{2}', 1, 2);
5
mysql> SELECT regexp_instr('abbabba', 'b{2}', 1, 3, 1);
7
```


