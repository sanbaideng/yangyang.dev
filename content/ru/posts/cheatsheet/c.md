---
название: C
дата: 2022-12-30 09:51:44
фон: bg-[#2a338a]
теги:
категории:
  - Программирование
intro: |
    Краткая справочная шпаргалка по языку C, содержащая основные сведения о синтаксисе и методах.
плагины:
    - copyCode
---

Начало работы
----



### hello.c {.row-span-2}

```c
#include <stdio.h>

int main(void) {
  printf("Hello World!\n");

  return 0;
}
```

Скомпилируйте файл `hello.c` с помощью `gcc`.

``bash
$ gcc hello.c -o hello
```

Запустить скомпилированный двоичный файл `hello`.

``bash
$ ./hello
```

Вывод => Hello World!



### Переменные {.row-span-2}

```c
int myNum = 15;

int myNum2; // не присваивать, а присваивать
myNum2 = 15;

int myNum3 = 15; // myNum3 равно 15
myNum3 = 10; // myNum3 теперь равно 10

float myFloat = 5.99; // число с плавающей точкой
char myLetter = 'D'; // символ

int x = 5;
int y = 6;
int sum = x + y; // добавление переменных к сумме

// объявить несколько переменных
int x = 5, y = 6, z = 50;
```



### Константы

```c
const int minutesPerHour = 60;
const float PI = 3.14;
```

Лучшие практики

```c
const int BIRTHYEAR = 1980;
```



### Комментарий

```c
// это комментарий
printf("Hello World!"); // Можно комментировать в любом месте файла

/*Многострочный комментарий, выводим Hello World!
на экран, это круто */
```



### Вывести текст

```c
printf("Я изучаю язык C.");
int testInteger = 5;
printf("Число = %d", testInteger);

float f = 5.99; // число с плавающей точкой
printf("Значение = %f", f);

short a = 0b1010110; // двоичное число
int b = 02713; // восьмеричное число
long c = 0X1DAB83; // шестнадцатеричное число

// вывод в восьмеричном виде
printf("a=%ho, b=%o, c=%lo\n", a, b, c);
// вывод => a=126, b=2713, c=7325603

// Вывод в десятичном виде
printf("a=%hd, b=%d, c=%ld\n", a, b, c);
// вывод => a=86, b=1483, c=1944451

// вывод в шестнадцатеричном виде (буквы строчные)
printf("a=%hx, b=%x, c=%lx\n", a, b, c);
// вывод => a=56, b=5cb, c=1dab83

// Вывод в шестнадцатеричном виде (заглавными буквами)
printf("a=%hX, b=%X, c=%lX\n", a, b, c);
// вывод => a=56, b=5CB, c=1DAB83
```



### Управление количеством пробелов

```c
int a1 = 20, a2 = 345, a3 = 700;
int b1 = 56720, b2 = 9999, b3 = 20098;
int c1 = 233, c2 = 205, c3 = 1;
int d1 = 34, d2 = 0, d3 = 23;

printf("%-9d %-9d %-9d\n", a1, a2, a3);
printf("%-9d %-9d %-9d\n", b1, b2, b3);
printf("%-9d %-9d %-9d\n", c1, c2, c3);
printf("%-9d %-9d %-9d\n", d1, d2, d3);
```

результат вывода

``bash
20 345 700
56720 9999 20098
233 205 1
34 0 23
```

В `%-9d`, `d` означает вывод по базе `10`, `9` означает занимать не менее `9` символов в ширину, а ширину не заполнять пробелами, `-` означает выравнивание влево



### Строки
```c
char greetings[] = "Hello World!";
printf("%s", greetings);
```

строка доступа

```c
char greetings[] = "Hello World!";
printf("%c", greetings[0]);
```

модифицировать строку

```c
char greetings[] = "Hello World!";
greetings[0] = 'J';

printf("%s", greetings);
// печатает "Jello World!"
```

Другой способ создания строки

```c
char greetings[] = {'H','e','l','l','\0'};

printf("%s", greetings);
// print "Hell!"
```

Создание строки с использованием символьного указателя (Литералы строк)
```c
char *greetings = "Hello";
printf("%s", greetings);
// вывести "Hello!"
```
**ПРИМЕЧАНИЕ**: Строковые литералы могут храниться в разделе памяти, доступном только для чтения. Модификация строкового литерала приводит к неопределенному поведению. Модифицировать его нельзя!

`C` **не имеет типа String, используйте тип `char` и создайте `массив` символов



### Условие {.row-span-2}

```c
int time = 20;
if (time < 18) {
  printf("До свидания!");
} else {
  printf("Добрый вечер!");
}
// Выход -> "Добрый вечер!"
int time = 22;
if (time < 10) {
  printf("Доброе утро!");
} else if (time < 20) {
  printf("До свидания!");
} else {
  printf("Добрый вечер!");
}
// Output -> "Good evening!"
```



### Тернарный оператор {.col-span-2}

```c
int age = 20;
(age > 19) ? printf("Взрослый") : printf("Подросток");
```



### Переключатель

```c
int day = 4;

switch (day) {
  case 3: printf("Wednesday"); break;
  case 4: printf("Четверг"); break;
  default:
    printf("Выходные!");
}
// output -> "Четверг" (день 4)
```



### Цикл While

```c
int i = 0;

while (i < 5) {
  printf("%d\n", i);
  i++;
}
```

**ПРИМЕЧАНИЕ**: Не забывайте инкрементировать переменную, используемую в условии, иначе цикл никогда не завершится и превратится в "бесконечный цикл"!



### Цикл Do/While

```c
int i = 0;

do {
  printf("%d\n", i);
  i++;
} while (i < 5);
```



### For Loop

```c
for (int i = 0; i < 5; i++) {
  printf("%d\n", i);
}
```



### Выход из цикла Break/Continue {.row-span-2}

```c
for (int i = 0; i < 10; i++) {
  if (i == 4) {
    break;
  }
  printf("%d\n", i);
}
```

выйти из цикла, когда `i` будет равно `4`

```c
for (int i = 0; i < 10; i++) {
  if (i == 4) {
    continue;
  }
  printf("%d\n", i);
}
```

Пример пропуска значения `4`



### While Break Пример

```c
int i = 0;

while (i < 10) {
  if (i == 4) {
    break;
  }
  printf("%d\n", i);

  i++;
}
```



### Продолжение примера

```c
int i = 0;

while (i < 10) {
  i++;

  if (i == 4) {
    продолжить;
  }
  printf("%d\n", i);
}
```



### Массивы {.row-span-2}

```c
int myNumbers[] = {25, 50, 75, 100};

printf("%d", myNumbers[0]);
// вывод 25
```

изменить элементы массива

```c
int myNumbers[] = {25, 50, 75, 100};
myNumbers[0] = 33;

printf("%d", myNumbers[0]);
```

Перебор массива

```c
int myNumbers[] = {25, 50, 75, 100};
int i;

for (i = 0; i < 4; i++) {
  printf("%d\n", myNumbers[i]);
}
```

установить размер массива

```c
// Объявляем массив из четырех целых чисел:
int myNumbers[4];

// добавляем элемент
myNumbers[0] = 25;
myNumbers[1] = 50;
myNumbers[2] = 75;
myNumbers[3] = 100;
```



### Перечисление Enum {.col-span-2}

```c
enum week { Mon = 1, Tues, Wed, Thurs, Fri, Sat, Sun };
```

определить переменную enum

```c
enum week a, b, c;
enum week { Mon = 1, Tues, Wed, Thurs, Fri, Sat, Sun } a, b, c;
```

С помощью переменной перечисления можно присвоить ей значение из списка

```c
enum week { Mon = 1, Tues, Wed, Thurs, Fri, Sat, Sun };
enum week a = Mon, b = Wed, c = Sat;
// или
enum week{ Mon = 1, Tues, Wed, Thurs, Fri, Sat, Sun } a = Mon, b = Wed, c = Sat;
```



### Перечислим примеры приложений

```c
enum week {Mon = 1, Tues, Wed, Thurs} day;

scanf("%d", &day);

switch(day) {
  case Mon: puts("понедельник"); break;
  case Tues: puts("Вторник"); break;
  case Wed: puts("Wednesday"); break;
  case Thursday: puts("Thursday"); break;
  default: puts("Error!");
}
```



### Пользовательский ввод

```c
// Создаем целочисленную переменную для хранения числа, полученного от пользователя
int myNum;

// Просим пользователя ввести число
printf("Пожалуйста, введите число: \n");

// Получить и сохранить число, введенное пользователем
scanf("%d", &myNum);

// Вывод числа, введенного пользователем
printf("Число, которое вы ввели: %d", myNum);
```



### Строка ввода пользователя

```c
// создаем строку
char firstName[30];
// Попросить пользователя ввести текст
printf("Введите ваше имя: \n");
// получить и сохранить текст
scanf("%s", &firstName);
// выводим текст
printf("Hello %s.", firstName);
```



### адрес памяти

При создании переменной ей присваивается адрес памяти

```c
int myAge = 43;

printf("%p", &myAge);
// Выходные данные: 0x7ffe5367e044
```

Для доступа к нему используйте оператор ссылки (`&`)



### создать указатель

```c
int myAge = 43; // переменная int
printf("%d", myAge); // вывод значения myAge(43)

// вывод адреса памяти myAge (0x7ffe5367e044)
printf("%p", &myAge);
```



### переменная-указатель {.col-span-2}

```c
int myAge = 43; // переменная int
int*ptr = &myAge; // переменная-указатель с именем ptr, используемая для хранения адреса myAge

printf("%d\n", myAge); // вывести значение myAge (43)

printf("%p\n", &myAge); // выводим адрес памяти myAge (0x7ffe5367e044)
printf("%p\n", ptr); // использование указателя (0x7ffe5367e044) для вывода адреса памяти myAge
```



### Dereference

```c
int myAge = 43; // объявление переменной
int*ptr = &myAge; // объявление указателя

// Ссылка: вывод myAge с помощью указателя
// адрес памяти (0x7ffe5367e044)
printf("%p\n", ptr);
// разыменование: вывод значения myAge с указателем (43)
printf("%d\n", *ptr);
```

Операторы
---



### Арифметические операторы

```c
int myNum = 100 + 50;
int sum1 = 100 + 50; // 150 (100 + 50)
int sum2 = sum1 + 250; // 400 (150 + 250)
int sum3 = sum2 + sum2; // 800 (400 + 400)
```

----

| Оператор | Имя | Пример |
|----------|-----------|---------|
| `+` | Сложение | `x + y` |
| `-` | Вычитание | `x - y` |
| `*` | Умножение | `x * y` |
| `/` | Деление | `x / y` |
| `%` | Modulo | `x % y` |
| `++` | Increment | `++x` |
| `--` | Уменьшение | `--x` |



### Оператор присваивания

| пример | как |
|-----------|----------------|
| x `=` 5 | x `=` 5 | |
| x `+=` 3 | x `=` x `+` 3 |
| x `-=` 3 | x `=` x `-` 3 |
| x `*=` 3 | x `=` x `*` 3 |
| x `/=` 3 | x `=` x `/` 3 |
| x `%=` 3 | x `=` x `%` 3 |
| x `&=` 3 | x `=` x `&` 3 |
| x `|=` 3 | x `=` x `|` 3 |
| x `^=` 3 | x `=` x `^` 3 |
| x `>>=` 3 | x `=` x `>>` 3 |
| x `<<=` 3 | x `=` x `<<` 3 |



### Операторы сравнения

```c
int x = 5;
int y = 3;

printf("%d", x > y);
// возвращает 1 (true), так как 5 больше 3
```

----

| Символ | Имя | Пример |
| --------| -------| -------|
| `==` | равно | x `==` y |
| `!=` | не равно | x `!=` y |
| `>` | больше | x `>` y |
| `<` | меньше | x `<` y |
| `>=` | больше или равно | x `>=` y |
| `<=` | меньше или равно | x `<=` y |

Операторы сравнения используются для сравнения двух значений



### Логические операторы {.col-span-2}

| Символ | Имя | Описание | Пример |
| --------| --------| --------| --------|
| `&&` | `and` логический | возвращает true, если оба утверждения истинны | `x < 5 && x < 10` |
| `||` | `or` logical | возвращает true, если одно из утверждений истинно | `x < 5 || x < 4` |
| `!` | `not` logical | Инвертирует результат, возвращает false, если true | `!(x < 5 && x < 10)` | |



### Примеры операторов {.row-span-2}

```c
unsigned int a = 60; /*60 = 0011 1100 */
unsigned int b = 13; /*13 = 0000 1101 */
int c = 0;

c = a & b; /*12 = 0000 1100 */
printf("Строка 1 - значение c равно %d\n", c);

c = a | b; /*61 = 0011 1101 */
printf("Строка 2 - значение c равно %d\n", c);
c = a ^ b; /*49 = 0011 0001 */
printf("Строка 3 - значение c равно %d\n", c);
c = ~a; /*-61 = 1100 0011 */
printf("Строка 4 - значение c равно %d\n", c);
c = a << 2; /*240 = 1111 0000 */
printf("Строка 5 - значение c равно %d\n", c);
c = a >> 2; /*15 = 0000 1111 */
printf("Строка 6 - значение c равно %d\n", c);
```



### Побитовые операторы {.col-span-2}

оператор | описание | экземпляр
:-|:-|:-
`&` | Оператор побитового AND, операция "AND" по двоичным цифрам | `(A & B)` даст `12`, что равно 0000 1100
`|` | Оператор поразрядного ИЛИ, операция "или" по двоичным цифрам | `(A | B)` получит `61`, что равно 0011 1101
`^` | Оператор XOR, выполните операцию "XOR" по двоичным цифрам | `(A ^ B)` и получите `49`, что равно 0011 0001
`~` | Оператор инверсии, выполнить операцию "инверсия" по двоичным разрядам | `(~A)` получим `-61`, что равно 1100 0011
`<<` | оператор двоичного сдвига влево | `A << 2` получим `240`, что равно 1111 0000
`>>` | двоичный оператор правого сдвига | `A >> 2` получит `15`, что равно 0000 1111

Типы данных
---



### Основные типы данных {.col-span-2}

| Тип данных | Размер Размер | Диапазон Диапазон | Описание Описание | Описание
| -----| -----| -----| -----|
| `char` | 1 байт | `-128` ~ `127` | одиночный символ/буквенно-цифровой/ASCII |
| `signed char` | 1 байт | `-128` ~ `127` | -|
| `беззнаковый char` | 1 байт | `0` ~ `255` | -|
| `int` | от `2` до `4` байт | `-32,768` ~ `32,767` | хранение целых чисел |
| | `signed int` | 2 байта | `-32,768` ~ `32,767` | | |
| ``unsigned int`` | 2 байта | `0` ~ `65,535`` | | |
| | `short int` | 2 байта | `-32,768` ~ `32,767` | | |
| `signed short int` | 2 байта | `-32,768` ~ `32,767` | | |
| ``unsigned short int`` | 2 байта | `0` ~ `65,535`` | | |
| `long int` | 4 байта | `-2,147,483,648` ~ `2,147,483,647` | | |
| `signed long int` | 4 байта | `-2,147,483,648` ~ `2,147,483,647` | | |
| ``unsigned long int`` | 4 байта | `0` ~ `4,294,967,295`` | | | |
| `float` | 4 байта | `3.4E-38` ~ `3.4E+38` | | | |
| | `double` | 8 байт | `1.7E-308` ~ `1.7E+308` | | | |
| | `long double` | 10 байт | `3.4E-4932` ~ `1.1E+4932` | | |



### Типы данных

```c
// создание переменных
int myNum = 5; // целое число
float myFloatNum = 5.99; // число с плавающей точкой
char myLetter = 'D'; // строка
// Данные или числа высокой точности с плавающей точкой
double myDouble = 3.2325467;
// печать выходных переменных
printf("%d\n", myNum);
printf("%f\n", myFloatNum);
printf("%c\n", myLetter);
printf("%lf\n", myDouble);
```

----

Тип данных | Описание
:-| :-
`char` | символьный тип
`short` | короткое целое число
`int` | целочисленный тип
`long` | длинное целое число
`float` | тип с плавающей точкой одинарной точности
`double` | тип с плавающей точкой двойной точности
`void` | нет типа



### Основные спецификаторы формата

| Спецификатор формата | Тип данных |
| -----| -----|
| `%d` или `%i` | `int` целое число |
| `%f` | `float` десятичный тип с одинарной точностью |
| `%lf` | `double` данные или число высокой точности с плавающей точкой |
| `%c` | `char` символ |
| `%s` | для строк `strings` |



### Основные спецификаторы формата

| | short | int | long |
| ----| ----| ----| ----|
| Octal | `%ho` | `%o` | `%lo` |
| Десятичная | `%hd` | `%d` | `%ld` |
| Шестнадцатеричная | `%hx` /`%hX` | `%x` /`%X` | `%lx` /`%lX` |



### Пример формата данных

```c
int myNum = 5;
float myFloatNum = 5.99; // число с плавающей точкой
char myLetter = 'D'; // строка
// печать выходных переменных
printf("%d\n", myNum);
printf("%f\n", myFloatNum);
printf("%c\n", myLetter);
```

Препроцессор C
---



### Директивы препроцессора {.row-span-2}

команда | описание
----| ----
`#define` | определить макрос
`#include` | включить файл исходного кода
`#undef` | неопределенный макрос
`#ifdef` | Возвращает true, если макрос определен
`#ifndef` | Возвращает true, если макрос не определен
`#if` | Компилирует следующий код, если заданное условие истинно
`#else` | Альтернатива `#if`
`#elif` | Если условие `#if` ложно, то текущее условие `true`.
`#endif` | Завершение блока условной компиляции `#if...#else`.
`#error` | Вывод сообщения об ошибке при возникновении стандартной ошибки
`#pragma` | Выдача специальных команд компилятору стандартным методом

```c
// заменить все MAX_ARRAY_LENGTH на 20
#define MAX_ARRAY_LENGTH 20
// Получить stdio.h из системной библиотеки
#include <stdio.h>
// Получить файл myheader.h из локального каталога
#include "myheader.h"
#undef FILE_SIZE
#define FILE_SIZE 42 // undefine и define to 42
```



### Предопределенные макросы {.row-span-2}

макрос | описание
----| ----
`__DATE__` | Текущая дата, символьная константа в формате "МММ ДД ГГГГ"
`__TIME__` | Текущее время, символьная константа в формате "HH:MM:SS"
`__FILE__` | Здесь будет содержаться имя текущего файла, строковая константа
`__LINE__` | Здесь будет содержаться номер текущей строки, десятичная константа
`__STDC__` | Определяется как `1`, если компилятор компилирует по стандарту `ANSI`.
<!--rehype:className=style-list-->

Стандарт `ANSI C` определяет ряд макросов, которые можно использовать, но нельзя напрямую изменять эти предопределенные макросы



#### Пример предопределенного макроса

```c
#include <stdio.h>

int main() {
  printf("Файл :%s\n", __FILE__);
  printf("Дата :%s\n", __DATE__);
  printf("Время :%s\n", __TIME__);
  printf("Строка :%d\n", __LINE__);
  printf("ANSI :%d\n", __STDC__);
}
```



### Оператор продолжения макроса (\)

Макрос обычно записывается в одну строку.

```c
#define message_for(a, b)\
    printf(#a " и " #b ": Мы вас любим!\n")
```

Если макрос слишком длинный, чтобы уместиться в одной строке, используйте оператор продолжения макроса `\`.



### Оператор константизации строк (#)

```c
#include <stdio.h>

#define message_for(a, b)\
  printf(#a " и " #b ": Мы вас любим!\n")

int main(void) {
  message_for(Carole, Debra);

  return 0;
}
```
При компиляции и выполнении приведенного выше кода получается следующий результат:

```
Кэрол и Дебра: Мы вас любим!
```

Если необходимо преобразовать макропараметр в строковую константу, используйте оператор строковой константы `#`.



Оператор вставки тега ### (##)

```c
#include <stdio.h>

#define tokenpaster(n) printf("token" #n " = %d", token##n)

int main(void) {
  int token34 = 40;
  tokenpaster(34);

  return 0;
}
```



### defined() operator

```c
#include <stdio.h>

#if !defined (MESSAGE)
   #define MESSAGE "You wish!"
#endif

int main(void) {
  printf("Вот сообщение: %s\n", MESSAGE);

  return 0;
}
```



### Параметризованные макросы

```c
int square(int x) {
  return x * x;
}
```

Макрос переписывает приведенный выше код следующим образом:

```c
#define square(x) ( (x) * (x) )
```

Между именем макроса и открывающей круглой скобкой пробелы не допускаются

```c
#include <stdio.h>
#define MAX(x,y) ( (x) > (y) ? (x) : (y) )

int main(void) {
  printf("Максимальное значение между 20 и 10 равно %d\n", MAX(10, 20));

  return 0;
}
```

C Function
----



### Объявление и определение функции {.row-span-2}

```c
int main(void) {
  printf("Hello World!");

  return 0;
}
```

Функция состоит из двух частей

```c
void myFunction() { // объявление декларации
  // тело функции (выполняемый код) (определение)
}
```

----
- `Декларация` объявляет имя функции, тип возврата и параметры _(если таковые имеются)_.
- `Определение` тело функции _(код для выполнения)_

----

```c
// объявление функции
void myFunction();
// главный метод
int main() {
  myFunction(); // --> вызов функции

  return 0;
}

void myFunction() {// Определение функции
  printf("Добрый вечер!");
}
```



### Вызов функции

```c
// создать функцию
void myFunction() {
  printf("Добрый вечер!");
}

int main() {
  myFunction(); // вызов функции
  myFunction(); // может быть вызвана несколько раз

  return 0;
}
// Output -> "Good evening!"
// Output -> "Good evening!"
```



### Параметры функции

```c
void myFunction(char name[]) {
  printf("Hello %s\n", name);
}

int main() {
  myFunction("Liam");
  myFunction("Jenny");

  return 0;
}
// Hello Liam
// Hello Jenny
```



### Множественные параметры

```c
void myFunction(char name[], int age) {
  printf("Привет %s, тебе %d лет.\n",name,age);
}
int main() {
  myFunction("Лиам", 3);
  myFunction("Дженни", 14);

  return 0;
}
// Привет Лиам, тебе 3 года.
// Привет, Дженни, тебе 14 лет.
```



### Возвращаемое значение {.row-span-2}

```c
int myFunction(int x) {
  return 5 + x;
}

int main() {
  printf("Результат: %d", myFunction(3));
  return 0;
}
// выход 8 (5 + 3)
```

два параметра

```c
int myFunction(int x, int y) {
  return x + y;
}

int main() {
  printf("Результат: %d", myFunction(5, 3));
  // сохраняем результат в переменной
  int result = myFunction(5, 3);
  printf("Результат = %d", result);

  return 0;
}
// result: 8 (5 + 3)
// result = 8 (5 + 3)
```



### Рекурсивный пример

```c
int sum(int k);

int main() {
  int result = sum(10);
  printf("%d", result);

  return 0;
}

int sum(int k) {
  if (k > 0) {
    return k + sum(k -1);
  } else {
    return 0;
  }
}
```



### Математические функции

```c
#include <math.h>

void main(void) {
  printf("%f", sqrt(16)); // квадратный корень
  printf("%f", ceil(1.4)); // округление в большую сторону (round)
  printf("%f", floor(1.4)); // округление в большую сторону (round)
  printf("%f", pow(4, 3)); // возведение x(4) в степень y(3)
}
```

----

- `abs(x)` абсолютное значение
- `acos(x)` значение косинуса дуги
- `asin(x)` дуговой синус
- `atan(x)` дуговой тангенс
- `cbrt(x)` кубический корень
- `cos(x)` косинус
- значение `exp(x)` экс
- `sin(x)` синус x
- тангенс угла `tan(x)`

C Структуры
---



### Создание структуры

```c
struct MyStructure { // объявление структуры
  int myNum; // член (переменная int)
  char myLetter; // член (переменная char)
}; // завершение структуры точкой с запятой
```

Создадим переменную struct с именем `s1`.

```c{7}
struct myStructure {
  int myNum;
  char myLetter;
};

int main() {
  struct myStructure s1;

  return 0;
}
```



### Строки в структуре

```c{9}
struct myStructure {
  int myNum;
  char myLetter;
  char myString[30]; // String
};

int main() {
  struct myStructure s1;
  strcpy(s1. myString, "Some text");
  // вывести значение
  printf("моя строка: %s", s1.myString);

  return 0;
}
```

Присвоение значений строкам с помощью функции `strcpy`



### Доступ к членам структуры {.row-span-2}

```c{11,12,16}
// создаем структуру myStructure
struct myStructure {
  int myNum;
  char myLetter;
};

int main() {
  // Создаем переменную структуры myStructure с именем s1
  struct myStructure s1;
  // Присваиваем значения членам s1
  s1.myNum = 13;
  s1.myLetter = 'B';

  // Создаем структурную переменную myStructure под названием s2
  // и присваиваем ей значение
  struct myStructure s2 = {13, 'B'};
  // выводим значение
  printf("Мое число: %d\n", s1.myNum);
  printf("Моя буква: %c\n", s1.myLetter);

  return 0;
}
```

Создание различных структурных переменных

```c
struct myStructure s1;
struct myStructure s2;
// Присваиваем значения переменным различных структур
s1.myNum = 13;
s1.myLetter = 'B';

s2.myNum = 20;
s2.myLetter = 'C';
```



### Копирование структуры

```c{6}
struct myStructure s1 = {
  13, 'B', "Некоторый текст"
};

struct myStructure s2;
s2 = s1;
```

В примере значение `s1` копируется в `s2`



### Изменить значение

```c{6,7}
// Создаем переменную struct и присваиваем ей значение
struct myStructure s1 = {
  13, 'B'
};
// изменяем значение
s1.myNum = 30;
s1.myLetter = 'C';
// выводим значение
printf("%d %c %s",
    s1.myNum,
    s1.myLetter);
```

обработка файла
---



### Функция обработки файлов

функция | описание Описание
----| ----
`fopen()` | `открытие` нового или существующего файла
`fprintf()` | запись данных в `файл`
`fscanf()` | `чтение` данных из файла
`fputc()` | запись символа в `файл`
`fgetc()` | `чтение` символа из файла
`fclose()` | `закрыть` файл
`fseek()` | установить указатель файла на `заданную позицию`.
`fputw()` | Запись целого числа `в` файл
`fgetw()` | `чтение` целого числа из файла
`ftell()` | возвращает текущую `позицию`.
`rewind()` | установка указателя файла в начало файла

В библиотеке языка Си имеется множество функций для `открытия`/ `чтения`/ `записи`/ `поиска` и `закрытия` файлов



### Параметр режима открытия

Режим Режим | Описание Описание
----| ----
`r` | Открыть текстовый файл в режиме `чтения`, позволяющем читать файл
`w` | Открыть текстовый файл в режиме `записи`, что позволяет производить запись в файл
`a` | Открыть текстовый файл в режиме `append`<br />Если файл не существует, то будет создан новый
`r+` | Открыть текстовый файл в режиме `чтение-запись`, позволяющем читать и записывать файл
`w+` | Открыть текстовый файл в режиме `чтение-запись`, позволяющем читать и записывать файл
`a+` | Открыть текстовый файл в режиме `чтение-запись`, разрешающем чтение и запись файла
`rb` | Открыть двоичный файл в режиме `чтение`.
`wb` | Открыть двоичный файл в режиме `запись`.
`ab` | Открыть двоичный файл в режиме `append`.
`rb+` | Открыть двоичный файл в режиме `чтение-запись`
`wb+` | Открыть двоичный файл в режиме `чтение-запись`
`ab+` | Открыть двоичный файл в режиме `чтение-запись`



### Открыть файл: fopen()

```c{6}
#include <stdio.h>

void main() {
  FILE *fp;
  char ch;

  fp = fopen("file_handle.c", "r");

  while (1) {
    ch = fgetc(fp);
    if (ch == EOF)
      break;
    printf("%c", ch);
  }
  fclose(fp);
}
```

После выполнения всех операций над файлом его необходимо закрыть с помощью `fclose()`.



### Запись в файл: fprintf()

```c{7}
#include <stdio.h>

void main() {
  FILE *fp;
  fp = fopen("file.txt", "w"); // открыть файл

  // запись данных в файл
  fprintf(fp, "Hello file for fprintf..\n");
  fclose(fp); // закрываем файл
}
```



### Чтение файла: fscanf()

```c{6}
#include <stdio.h>

void main() {
  FILE *fp;

  char buff[255]; // Создание массива char для хранения данных файла
  fp = fopen("file.txt", "r");

  while(fscanf(fp, "%s", buff) != EOF) {
    printf("%s ", buff);
  }
  fclose(fp);
}
```



### Запись в файл: fputc()

```c{6}
#include <stdio.h>

void main() {
  FILE *fp;
  fp = fopen("file1.txt", "w"); // открываем файл
  fputc('a',fp); // запись одного символа в файл
  fclose(fp); // закрываем файл
}
```



### Чтение файла: fgetc()

```c{8}
#include <stdio.h>
#include <conio.h>

void main() {
  FILE *fp;
  char c;

  clrscr();

  fp = fopen("myfile.txt", "r");

  while( (c = fgetc(fp) ) != EOF) {
    printf("%c", c);
  }
  fclose(fp);

  getch();
}
```



### Запись в файл: fputs()

```c {8}
#include<stdio.h>
#include<conio.h>

void main() {
  FILE *fp;

  clrscr();

  fp = fopen("myfile2.txt", "w");
  fputs("hello c programming",fp);
  fclose(fp);

  getch();
}
```



### Чтение файлов: fgets()

```c {10}
#include<stdio.h>
#include<conio.h>

void main() {
  FILE *fp;
  char text[300];

  clrscr();

  fp = fopen("myfile2.txt", "r");
  printf("%s", fgets(text, 200, fp));
  fclose(fp);

  getch();
}
```



### fseek()

```c{8}
#include <stdio.h>

void main(void) {
  FILE *fp;

  fp = fopen("myfile.txt", "w+");
  fputs("Это книга", fp);

  // Устанавливаем указатель файла в заданную позицию
  fseek(fp, 7, SEEK_SET);

  fputs("Kenny Wong", fp);
  fclose(fp);
}
```

установить указатель файла в заданную позицию



### перемотка()

```c{11}
#include <stdio.h>
#include <conio.h>

void main() {
  FILE *fp;
  char c;

  clrscr();

  fp = fopen("file.txt", "r");

  while( (c = fgetc(fp) ) != EOF) {
    printf("%c", c);
  }

  rewind(fp); // перемещение указателя файла в начало файла

  while( (c = fgetc(fp) ) != EOF) {
    printf("%c", c);
  }
  fclose(fp);

  getch();
}
// вывод
// Hello World! Hello World!
```



### ftell()

```c{11}
#include <stdio.h>
#include <conio.h>

void main () {
   FILE *fp;
   int length;

   clrscr();

   fp = fopen("file.txt", "r");

   fseek(fp, 0, SEEK_END);
   length = ftell(fp); // возврат текущей позиции
   fclose(fp);

   printf("Размер файла: %d байт", length);

   getch();
}
// вывод
// размер файла: 18 байт
```
