---
Название: Neo4j
дата: 2021-08-23 12:34:56
фон: bg-[#3b85ef]
теги:
    - БД
    - GraphDB
категории:
  - Базы данных
intro: |
    Шпаргалка по Neo4j с ресурсами для начала работы и информацией о том, как запрашивать базу данных с помощью Cypher.
плагины:
    - copyCode
---

Начало работы {.cols-2}
---------------

### Начало работы с Neo4j

Neo4j - это графическая база данных, состоящая из узлов, связанных между собой отношениями.  Вы можете рассмотреть возможность использования базы данных Graph, если у вас есть сильно связанный набор данных или запросы с большим количеством соединений.

- [Download Neo4j Desktop](https://neo4j.com/download) _скачать Neo4j desktop или server editions_.
- [Neo4j Sandbox](https://sandbox.neo4j.com) _выберите набор данных - установка не требуется_.
- [Neo4j Aura](https://neo4j.com/aura) _бесплатный экземпляр Neo4j в облаке_
- [Neo4j GraphAcademy](https://neo4j.com/graphacademy) _бесплатное, самостоятельное, практическое обучение онлайн_
- [GraphGists](https://neo4j.com/graphgists) _использование асе и отраслевых примеров графиков_.

### Концепции баз данных графов

| | |
|-----------|-------------------------------------------------------------------------------------------------------------------|
| **Узлы** | Узлы обычно используются для представления _существ_ или _вещей_ в ваших данных.  Например, **Person** или **Movie**.
| **Связи** | Связи используются для соединения двух узлов между собой и организации данных в структуру.  Например, человек **играл в** фильме.  Отношения имеют _тип_ и _направление_, хотя направление может игнорироваться во время запроса.
| **Метки** | Метки используются для группировки узлов по категориям.  Например, у человека могут быть метки `Person` и `Actor`.
| **Тип связи** | Каждая связь имеет свой тип.  Отношения позволяют исследовать более мелкие участки графа. |
| **Свойства** | Как узлы, так и отношения могут иметь свойства, установленные для них.  Свойства представляют собой [пары имя-значение] (https://neo4j.com/docs/cypher-manual/4.3/syntax/values/#cypher-values). |


Синтаксис Neo4j
------

### Чтение структуры запроса

```
[USE]
[MATCH WHERE]
[OPTIONAL MATCH WHERE]
[WITH [ORDER BY] [SKIP] [LIMIT]]
RETURN [ORDER BY] [SKIP] [LIMIT]
```

### Структура запроса, доступного только для записи

```
[USE]
(CREATE | MERGE)*
[SET|DELETE|REMOVE|FOREACH]*
[RETURN [ORDER BY] [SKIP] [LIMIT]]
```


### Структура запроса для чтения-записи

```
[USE]
[MATCH WHERE]
[OPTIONAL MATCH WHERE]
[WITH [ORDER BY] [SKIP] [LIMIT]]
(CREATE | MERGE)*
[SET|DELETE|REMOVE|FOREACH]*
[RETURN [ORDER BY] [SKIP] [LIMIT]]
```


Neo4j Чтение данных
------------

### MATCH

```
MATCH (n:Person)-[:KNOWS]->(m:Person)
WHERE n.name = 'Alice'
```
Шаблоны узлов могут содержать метки и свойства.



```
MATCH (n)-->(m)
```
В MATCH может быть использован любой шаблон.



```
MATCH (n {имя: 'Алиса'})-->(m)
```
Паттерны со свойствами узлов.



```
MATCH p = (n)-->(m)
```
Присвоить путь к p.



```
OPTIONAL MATCH (n)-[r]->(m)
```
Необязательный шаблон: для недостающих частей будут использоваться нули.



### WHERE

```
WHERE n.property <> $value
```
Используйте предикат для фильтрации. Обратите внимание, что WHERE всегда является частью предложения MATCH, OPTIONAL MATCH или WITH. Если поместить его после другого предложения в запросе, то его действие изменится.



```
WHERE EXISTS {
  MATCH (n)-->(m) WHERE n.age = m.age
}
```
Использование экзистенциального подзапроса для фильтрации.



### RETURN

```
RETURN *
```
Вернуть значение всех переменных.



```
RETURN n AS columnName
```
Использование псевдонима для имени столбца результата.



```
RETURN DISTINCT n
```
Возврат уникальных строк.



```
ORDER BY n.property
```
Отсортируйте результат.



```
ORDER BY n.property DESC
```
Сортировка результата в порядке убывания.



```
SKIP $skipNumber
```
Пропускает определенное количество результатов.



```
LIMIT $limitNumber
```
Ограничивает количество результатов.



```
SKIP $skipNumber LIMIT $limitNumber
```
Пропускает результаты сверху и ограничивает количество результатов.



```
RETURN count(*)
```
Количество совпавших строк. Подробнее см. в разделе Агрегирующие функции.



### WITH

```
MATCH (user)-[:FRIEND]-(friend)
WHERE user.name = $name
WITH user, count(friend) AS friends
WHERE friends > 10
RETURN user
```
Синтаксис WITH аналогичен синтаксису RETURN. Он явно разделяет части запроса, позволяя объявить, какие переменные следует перенести в следующую часть.



```
MATCH (user)-[:FRIEND]-(friend)
WITH user, count(friend) AS friends
ORDER BY friends DESC
  SKIP 1
  LIMIT 3
RETURN user
```
ORDER BY, SKIP и LIMIT могут также использоваться с WITH.



### UNION

```
MATCH (a)-[:KNOWS]->(b)
RETURN b.name
UNION
MATCH (a)-[:LOVES]->(b)
RETURN b.name
```
Возвращает отчетливое объединение всех результатов запроса. Типы и имена столбцов результатов должны совпадать.



```
MATCH (a)-[:KNOWS]->(b)
RETURN b.name
ОБЪЕДИНЕНИЕ ВСЕХ
MATCH (a)-[:LOVES]->(b)
ВОЗВРАТ b.name
```
Возвращает объединение всех результатов запроса, включая дублирующиеся строки.



Neo4j Запись данных
-------------


### CREATE

```
CREATE (n {name: $value})
```
Создает узел с заданными свойствами.



```
CREATE (n $map)
```
Создает узел с заданными свойствами.



```
UNWIND $listOfMaps AS properties
CREATE (n) SET n = properties
```
Создать узлы с заданными свойствами.



```
CREATE (n)-[r:KNOWS]->(m)
```
Создает отношение с заданным типом и направлением; привязывает к нему переменную.



```
CREATE (n)-[:LOVES {since: $value}]->(m)
```
Создает отношение с заданным типом, направлением и свойствами.



### SET

```
SET n.property1 = $value1,
    n.property2 = $value2
```
Обновление или создание свойства.



```
SET n = $map
```
Установить все свойства. При этом все существующие свойства будут удалены.



```
SET n += $map
```
Добавление и обновление свойств с сохранением существующих.



```
SET n:Person
```
Добавляет к узлу метку Person.



### MERGE

```
MERGE (n:Person {name: $value})
  ON CREATE SET n.created = timestamp()
  ON MATCH SET
    n.counter = coalesce(n.counter, 0) + 1,
    n.accessTime = timestamp()
```
Сопоставление шаблона или его создание, если он не существует. Используйте ON CREATE и ON MATCH для условного обновления.



```
MATCH (a:Person {name: $value1}),
      (b:Person {имя: $value2})
MERGE (a)-[r:LOVES]->(b)
```
MERGE находит или создает связь между узлами.



```
MATCH (a:Person {name: $value1})
MERGE
  (a)-[r:KNOWS]->(b:Person {имя: $value3})
```
MERGE находит или создает пути, присоединенные к узлу.



### DELETE

```
DELETE n, r
```
Удаление узла и отношения.



```
DETACH DELETE n
```
Удаляет узел и все связанные с ним отношения.



```
СРАВНИТЬ (n)
УДАЛИТЬ УДАЛИТЬ n
```
Удалить все узлы и связи из базы данных.



### REMOVE

```
УДАЛИТЬ n:Person
```
Удалить метку из n.



```
REMOVE n.property
```
Удалить свойство.



### FOREACH

```
FOREACH (r IN relationships(path)|
  SET r.marked = true)
```
Выполнение мутирующей операции для каждого отношения в пути.



```
FOREACH (value IN coll |
 CREATE (:Person {name: value}))
```
Выполнение мутирующей операции для каждого элемента списка.



### CALL subquery

```
CALL {
  MATCH (p:Person)-[:FRIEND_OF]->(other:Person) RETURN p, other
  UNION
  MATCH (p:Child)-[:CHILD_OF]->(other:Parent) RETURN p, other
}
```
Здесь вызывается подзапрос с двумя объединяющими частями. Результат подзапроса может быть впоследствии обработан.



### CALL procedure

```
CALL db.labels() YIELD label
```
Здесь показан автономный вызов встроенной процедуры db.labels для получения списка всех меток, используемых в базе данных. Обратите внимание, что необходимые аргументы процедуры указываются в явном виде в скобках после имени процедуры.



```
CALL db.labels() YIELD *
```
Автономные вызовы могут использовать YIELD * для возврата всех столбцов.



```
CALL java.stored.procedureWithArgs
```
Автономные вызовы могут опускать YIELD, а также предоставлять аргументы неявно через параметры оператора, например, автономный вызов, требующий один аргумент input, может быть запущен путем передачи карты параметров {input: 'foo'}.



```
CALL db.labels() YIELD label
RETURN count(label) AS count
```
Вызывает встроенную процедуру db.labels внутри более крупного запроса для подсчета всех меток, используемых в базе данных. Вызов внутри более крупного запроса всегда требует передачи аргументов и именования результатов явным образом с помощью YIELD.



### Импорт

```
LOAD CSV FROM
'https://neo4j.com/docs/cypher-refcard/4.3/csv/artists.csv' AS line
CREATE (:Artist {name: line[1], year: toInteger(line[2])})
```
Загрузка данных из CSV-файла и создание узлов.



```
ЗАГРУЗИТЬ CSV С ЗАГОЛОВКАМИ ИЗ
'https://neo4j.com/docs/cypher-refcard/4.3/csv/artists-with-headers.csv' AS line
CREATE (:Artist {name: line.Name, year: toInteger(line.Year)})
```
Загрузка CSV-данных, содержащих заголовки.



```
ИСПОЛЬЗОВАНИЕ ПЕРИОДИЧЕСКОЙ ФИКСАЦИИ 500
ЗАГРУЗИТЬ CSV С ЗАГОЛОВКАМИ ИЗ
'https://neo4j.com/docs/cypher-refcard/4.3/csv/artists-with-headers.csv' AS line
CREATE (:Artist {name: line.Name, year: toInteger(line.Year)})
```
При импорте больших объемов данных фиксация текущей транзакции происходит через каждые 500 строк.



```
LOAD CSV FROM
'https://neo4j.com/docs/cypher-refcard/4.3/csv/artists-fieldterminator.csv'
AS line FIELDTERMINATOR ';'
CREATE (:Artist {name: line[1], year: toInteger(line[2])})
```
Используйте другой терминатор полей, а не тот, который используется по умолчанию - запятую (без пробелов вокруг нее).



```
LOAD CSV FROM
'https://neo4j.com/docs/cypher-refcard/4.3/csv/artists.csv' AS line
RETURN DISTINCT file()
```
Возвращает абсолютный путь к файлу, который обрабатывает LOAD CSV, при вызове вне контекста LOAD CSV возвращается null.



```
LOAD CSV FROM
'https://neo4j.com/docs/cypher-refcard/4.3/csv/artists.csv' AS line
RETURN linenumber()
```
Возвращает номер строки, которую в данный момент обрабатывает LOAD CSV, при вызове вне контекста LOAD CSV возвращается null.



### Операторы

| | |
|------------------------|-------------------------------------------|
| **Общие** | DISTINCT, ., [] |
| **Математические** | +, -, *, /, %, ^ |
| **Сравнение** | =, <>, <, >, <=, >=, IS NULL, IS NOT NULL |
| **Boolean** | AND, OR, XOR, NOT |
| **String** | + |
| **Список** | +, IN, [x], [x ... y] | |
| **Регулярное выражение** | =~ |
| **Строковое соответствие** | STARTS WITH, ENDS WITH, CONTAINS |


### null

* `null` используется для представления отсутствующих/неопределенных значений.

* `null` не равно `null`. Незнание двух значений не означает, что они являются одним и тем же значением. Поэтому выражение `null = null` дает `null`, а не `true`. Чтобы проверить, является ли выражение `null`, используйте функцию `IS NULL`.
* Арифметические выражения, сравнения и вызовы функций (кроме `coalesce`) возвращают `null`, если какой-либо аргумент является `null`.
* Попытка доступа к отсутствующему элементу списка или несуществующему свойству приводит к возврату `null`.
* В предложениях `OPTIONAL MATCH` для отсутствующих частей шаблона будут использоваться `null`.


### Patterns

```
(n:Person)
```
Узел с меткой Person.



```
(n:Person:Swedish)
```
Узел с метками Person и Swedish.



```
(n:Person {name: $value})
```
Узел с объявленными свойствами.



```
()-[r {имя: $value}]-()
```
Сопоставляет отношения с объявленными свойствами.



```
(n)-->(m)
```
Отношение от n к m.



```
(n)--(m)
```
Связь в любом направлении между n и m.



```
(n:Person)-->(m)
```
Узел n помечен как Person с отношением к m.



```
(m)<-[:KNOWS]-(n)
```
Отношение типа KNOWS от n к m.



```
(n)-[:KNOWS|:LOVES]->(m)
```
Отношение типа KNOWS или типа LOVES от n к m.



```
(n)-[r]->(m)
```
Привязать отношение к переменной r.



```
(n)-[*1..5]->(m)
```
Путь переменной длины от 1 до 5 связей от n до m.



```
(n)-[*]->(m)
```
Путь переменной длины из любого количества отношений от n до m. (См. раздел "Производительность").



```
(n)-[:KNOWS]->(m {свойство: $значение})
```
Отношение типа KNOWS от узла n к узлу m с объявленным свойством.



```
shortestPath((n1:Person)-[*..6]-(n2:Person))
```
Найти единственный кратчайший путь.



```
allShortestPaths((n1:Person)-[*..6]->(n2:Person))
```
Найти все кратчайшие пути.



```
size((n)-->()-->())
```
Подсчитать пути, соответствующие шаблону.



### USE

```
USE myDatabase
```
Выберите базу данных myDatabase для выполнения запроса или части запроса.



```
USE neo4j
MATCH (n:Person)-[:KNOWS]->(m:Person)
WHERE n.name = 'Alice'
```
Выполнение запроса MATCH к базе данных neo4j.



### SHOW FUNCTIONS and PROCEDURES

```
ПОКАЗАТЬ ФУНКЦИИ
```
Вывод списка всех доступных функций.



```
SHOW PROCEDURES EXECUTABLE YIELD name
```
Перечислить все процедуры, которые могут быть выполнены текущим пользователем, и вернуть только имя процедуры.



### Ярлыки

```
CREATE (n:Person {name: $value})
```
Создание узла с меткой и свойством.



```
MERGE (n:Person {name: $value})
```
Сопоставляет или создает уникальный узел (узлы) с меткой и свойством.



```
SET n:Супруг:Родитель:Сотрудник
```
Добавить метку (метки) к узлу.



```
MATCH (n:Person)
```
Сопоставляет узлы с меткой Person.



```
MATCH (n:Person)
WHERE n.name = $value
```
Сопоставляет узлы с меткой Person с заданным именем.



```
WHERE (n:Person)
```
Проверяет существование метки на узле.



```
labels(n)
```
Метки узла.



```
REMOVE n:Person
```
Удалить метку из узла.



### Списки

```
['a', 'b', 'c'] AS list
```
Буквальные списки объявляются в квадратных скобках.



```
size($list) AS len, $list[0] AS value
```
Списки могут передаваться в качестве параметров.



```
range($firstNum, $lastNum, $step) AS list
```
range() создает список чисел (шаг необязателен), другие функции, возвращающие списки: labels(), nodes(), relationships().



```
MATCH p = (a)-[:KNOWS*]->()
RETURN relations(p) AS r
```
Список отношений, составляющих путь переменной длины, может быть возвращен с помощью именованных путей и функции relationships().



```
RETURN matchedNode.list[0] AS value,
       size(matchedNode.list) AS len
```
Свойства могут представлять собой списки строк, чисел или булевых значений.



```
list[$idx] AS value,
list[$startIdx..$endIdx] AS slice
```
Доступ к элементам списка осуществляется с помощью подстрочных индексов idx в квадратных скобках. Неверные индексы возвращают null. Слайсы могут быть получены с интервалом от start_idx до end_idx, каждый из которых может быть опущен или отрицателен. Элементы, выходящие за пределы интервала, игнорируются.



```
UNWIND $names AS name
MATCH (n {name: name})
RETURN avg(n.age)
```
С помощью UNWIND любой список может быть преобразован обратно в отдельные строки. В примере выполняется поиск всех имен из списка имен.



```
MATCH (a)
RETURN [(a)-->(b) WHERE b.name = 'Bob' | b.age]
```
Понимание шаблона может быть использовано для выполнения пользовательской проекции из совпадения непосредственно в список.



```
MATCH (person)
RETURN person { .name, .age}
```
Проекции карты могут быть легко построены из узлов, отношений и других значений карты.



### Карты

```
{ имя: 'Алиса', возраст: 38,
 адрес: {city: 'London', residential: true}}
```
Буквальные карты объявляются в фигурных скобках, как и карты свойств. Поддерживаются списки.



```
WITH {person: {name: 'Anne', age: 25}} AS p
RETURN p.person.name
```
Доступ к свойству вложенной карты.



```
MERGE (p:Person {name: $map.name})
  ON CREATE SET p = $map
```
Карты могут передаваться в качестве параметров и использоваться либо как карта, либо путем доступа к ключам.



```
MATCH (matchedNode:Person)
RETURN matchedNode
```
Узлы и отношения возвращаются в виде карт их данных.



```
map.name, map.age, map.children[0]
```
Доступ к элементам карты осуществляется по их ключам. Неверные ключи приводят к ошибке.



### Предикаты

```
n.property <> $value
```
Используйте операторы сравнения.



```
toString(n.property) = $value
```
Использование функций.



```
n.number >= 1 AND n.number <= 10
```
Для объединения предикатов используйте булевы операторы.



```
1 <= n.number <= 10
```
Для объединения предикатов используйте цепочечные операторы.



```
n:Person
```
Проверка наличия меток узлов.



```
переменная IS NOT NULL
```
Проверяет, не является ли что-то null, например, существует ли свойство.



```
n.property IS NULL OR n.property = $value
```
Либо свойство не существует, либо предикат истинен.



```
n.property = $value
```
Несуществующее свойство возвращает null, которое ничему не равно.



```
n["property"] = $value
```
Доступ к свойствам также может осуществляться с помощью динамически вычисляемого имени свойства.



```
n.property STARTS WITH 'Tim' OR
n.property ENDS WITH 'n' OR
n.property CONTAINS 'goodie'
```
Сопоставление строк.



```
n.property =~ 'Tim.*'
```
Сопоставление строковых регулярных выражений.



```
(n)-[:KNOWS]->(m)
```
Убедитесь, что шаблон имеет хотя бы одно совпадение.



```
NOT (n)-[:KNOWS]->(m)
```
Исключить из результата совпадения с (n)-[:KNOWS]->(m).



```
n.property IN [$value1, $value2]
```
Проверка наличия элемента в списке.



### Предикаты списка

```
all(x IN coll WHERE x.property IS NOT NULL)
```
Возвращает true, если предикат истинен для всех элементов списка.



```
any(x IN coll WHERE x.property IS NOT NULL)
```
Возвращает true, если предикат истинен хотя бы для одного элемента в списке.



```
none(x IN coll WHERE x.property IS NOT NULL)
```
Возвращает true, если предикат ложен для всех элементов списка.



```
single(x IN coll WHERE x.property IS NOT NULL)
```
Возвращает true, если предикат истинен ровно для одного элемента в списке.



### CASE

```
CASE n.eyes
 WHEN 'blue' THEN 1
 WHEN 'brown' THEN 2
 ИЛИ 3
END
```
Возвращает значение THEN из совпадающего значения WHEN. Значение ELSE является необязательным и в случае отсутствия заменяется на null.



```
CASE
 WHEN n.eyes = 'blue' THEN 1
 WHEN n.age < 40 THEN 2
 ELSE 3
END
```
Возвращает значение THEN из первого предиката WHEN, оценивающегося как true. Предикаты оцениваются по порядку.



### Списочные выражения

```
size($list)
```
Количество элементов в списке.



```
reverse($list)
```
Обратный порядок элементов в списке.



```
head($list), last($list), tail($list)
```
head() возвращает первый, last() - последний элемент списка. tail() возвращает все элементы, кроме первого. Все они возвращают null для пустого списка.



```
[x IN list | x.prop]
```
Список, содержащий значение выражения для каждого элемента исходного списка.



```
[x IN list WHERE x.prop <> $value]
```
Отфильтрованный список элементов, для которых предикат истинен.



```
[x IN list WHERE x.prop <> $value | x.prop]
```
Списочное вычисление, которое фильтрует список и извлекает значение выражения для каждого элемента этого списка.



```
reduce(s = "", x IN list | s + x.prop)
```
Оценить выражение для каждого элемента списка, накопить результаты.



### Функции

```
coalesce(n.property, $defaultValue)
```
Первое ненулевое выражение.



```
timestamp()
```
Миллисекунды с полуночи 1 января 1970 года по Гринвичу.



```
id(nodeOrRelationship)
```
Внутренний идентификатор отношения или узла.



```
toInteger($expr)
```
Преобразует заданный входной сигнал в целое число, если это возможно; в противном случае возвращает null.



```
toFloat($expr)
```
Преобразует заданный входной сигнал в число с плавающей точкой, если это возможно; в противном случае возвращает null.



```
toBoolean($expr)
```
Преобразует заданный входной сигнал в булево число, если это возможно; в противном случае возвращает null.



```
keys($expr)
```
Возвращает список строковых представлений имен свойств узла, отношения или карты.



```
properties($expr)
```
Возвращает карту, содержащую все свойства узла или отношения.



### Функции пути

```
length(path)
```
Количество связей в пути.



```
nodes(path)
```
Узлы в пути в виде списка.



```
relations(path)
```
Отношения в пути в виде списка.



```
[x IN nodes(path) | x.prop]
```
Извлечение свойств из узлов пути.



### Пространственные функции

```
point({x: $x, y: $y})
```
Возвращает точку в двумерной картезианской системе координат.



```
point({latitude: $y, longitude: $x})
```
Возвращает точку в двумерной географической системе координат с координатами, заданными в десятичных градусах.



```
point({x: $x, y: $y, z: $z})
```
Возвращает точку в трехмерной картезианской системе координат.



```
point({latitude: $y, longitude: $x, height: $z})
```
Возвращает точку в трехмерной географической системе координат с широтой и долготой в десятичных градусах и высотой в метрах.



```
distance(point({x: $x1, y: $y1}), point({x: $x2, y: $y2}))
```
Возвращает число с плавающей точкой, представляющее линейное расстояние между двумя точками. Возвращаемые единицы измерения совпадают с единицами измерения координат точки и работают как для двумерных, так и для трехмерных картезианских точек.



```
distance(point({latitude: $y1, longitude: $x1}), point({latitude: $y2, longitude: $x2}))
```
Возвращает геодезическое расстояние между двумя точками в метрах. Может использоваться и для трехмерных географических точек.



Функции Neo4j
---------
### Темпоральные функции

```
date("2018-04-05")
```
Возвращает дату, разобранную из строки.



```
localtime("12:45:30.25")
```
Возвращает время без указания часового пояса.



```
time("12:45:30.25+01:00")
```
Возвращает время в указанном часовом поясе.



```
localdatetime("2018-04-05T12:34:00")
```
Возвращает время без часового пояса.



```
datetime("2018-04-05T12:34:00[Europe/Berlin]")
```
Возвращает время в указанном часовом поясе.



```
datetime({epochMillis: 3360000})
```
Преобразует 3360000 как время UNIX Epoch в обычное время datetime.



```
date({year: $year, month: $month, day: $day})
```
Все временные функции также могут быть вызваны с помощью карты именованных компонентов. В данном примере возвращается дата из компонентов year, month и day. Каждая функция поддерживает свой набор возможных компонентов.



```
datetime({date: $date, time: $time})
```
Временные типы могут быть созданы путем комбинирования других типов. В данном примере datetime создается из даты и времени.



```
date({date: $datetime, day: 5})
```
Временные типы могут быть созданы путем выбора из более сложных типов, а также переопределения отдельных компонентов. В данном примере дата создается путем выбора из datetime, а также переопределения компонента day.



```
WITH date("2018-04-05") AS d
RETURN d.year, d.month, d.day, d.week, d.dayOfWeek
```
Аксессоры позволяют извлекать компоненты временных типов.



### Функции длительности

```
duration("P1Y2M10DT12H45M30.25S")
```
Возвращает длительность 1 год, 2 месяца, 10 дней, 12 часов, 45 минут и 30,25 секунды.



```
duration.between($date1,$date2)
```
Возвращает длительность между двумя временными интервалами.



```
WITH duration("P1Y2M10DT12H45M") AS d
RETURN d.years, d.months, d.days, d.hours, d.minutes
```
Возвращает 1 год, 14 месяцев, 10 дней, 12 часов и 765 минут.



```
WITH duration("P1Y2M10DT12H45M") AS d
RETURN d.years, d.monthsOfYear, d.days, d.hours, d.minutesOfHour
```
Возвращает 1 год, 2 месяца, 10 дней, 12 часов и 45 минут.



```
date("2015-01-01") + duration("P1Y1M1D")
```
Возвращает дату 2016-02-02. Также возможно вычитание длительностей из временных экземпляров.



```
duration("PT30S") * 10
```
Возвращает длительность 5 минут. Также возможно деление длительности на число.



### Математические функции

```
abs($expr)
```
Абсолютное значение.



```
rand()
```
Возвращает случайное число в диапазоне от 0 (включительно) до 1 (исключая), [0,1). При каждом вызове возвращает новое значение. Также полезен для выбора подмножества или случайного упорядочивания.



```
round($expr)
```
Округляем до ближайшего целого числа; ceil() и floor() находят следующее целое число вверх или вниз.



```
sqrt($expr)
```
Квадратный корень.



```
sign($expr)
```
0, если ноль, -1, если отрицательный, 1, если положительный.



```
sin($expr)
```
К тригонометрическим функциям также относятся cos(), tan(), cot(), asin(), acos(), atan(), atan2() и haversin(). Все аргументы тригонометрических функций должны быть в радианах, если не указано иное.



```
градусы($expr), радианы($expr), pi()
```
Преобразует радианы в градусы; для обратного преобразования используйте radians(), а для π - pi().



```
log10($expr), log($expr), exp($expr), e()
```
Логарифм по основанию 10, натуральный логарифм, e в степени параметра и значение e.



### Строковые функции

```
toString($expression)
```
Строковое представление выражения.



```
replace($original, $search, $replacement)
```
Заменяет все вхождения search на replacement. Все аргументы должны быть выражениями.



```
substring($original, $begin, $subLength)
```
Получение части строки. Аргумент subLength является необязательным.



```
left($original, $subLength),
  right($original, $subLength)
```
Первая часть строки. Последняя часть строки.



```
trim($original), lTrim($original),
  rTrim($original)
```
Обрезает все пробельные символы, либо с левой, либо с правой стороны.



```
toUpper($original), toLower($original)
```
UPPERCASE и lowercase.



```
split($original, $delimiter)
```
Разбивает строку на список строк.



```
reverse($original)
```
Обратное преобразование строки.



```
size($string)
```
Вычисляет количество символов в строке.



### Функции отношения

```
type(a_relationship)
```
Строковое представление типа отношения.



```
startNode(a_relationship)
```
Начальный узел отношения.



```
endNode(a_relationship)
```
Конечный узел отношения.



```
id(a_relationship)
```
Внутренний идентификатор отношения.



### Агрегирующие функции

```
count(*)
```
Количество совпадающих строк.



```
count(variable)
```
Количество ненулевых значений.



```
count(DISTINCT variable)
```
Все агрегатные функции также используют оператор DISTINCT, который удаляет дубликаты из значений.



```
collect(n.property)
```
Список из значений, игнорирует null.



```
sum(n.property)
```
Суммирует числовые значения. Аналогичными функциями являются avg(), min(), max().



```
percentileDisc(n.property, $percentile)
```
Дискретный перцентиль. Непрерывный перцентиль - percentileCont(). Аргумент percentile имеет значение от 0.0 до 1.0.



```
stDev(n.property)
```
Стандартное отклонение для выборки из популяции. Для всей совокупности используйте stDevP().



Операции со схемами Neo4j
------

### ИНДЕКС

```
CREATE INDEX FOR (p:Person) ON (p.name)
```
Создадим индекс на узлах с меткой Person и свойством name.



```
CREATE INDEX index_name FOR ()-[k:KNOWS]-() ON (k.since)
```
Создать индекс на отношениях с типом KNOWS и свойством since с именем index_name.



```
CREATE INDEX FOR (p:Person) ON (p.surname)
OPTIONS {indexProvider: 'native-btree-1.0', indexConfig: {`spatial.cartesian.min`: [-100.0, -100.0], `spatial.cartesian.max`: [100.0, 100.0]}}
```
Создадим индекс на узлах с меткой Person и свойством surname с индексным провайдером native-btree-1.0 и заданными настройками spatial.cartesian. Остальные параметры индекса будут иметь значения по умолчанию.



```
CREATE INDEX FOR (p:Person) ON (p.name, p.age)
```
Создает составной индекс на узлах с меткой Person и свойствами name и age, выдает ошибку, если индекс уже существует.



```
CREATE INDEX IF NOT EXISTS FOR (p:Person) ON (p.name, p.age)
```
Создает составной индекс на узлах с меткой Person и свойствами name и age, если он еще не существует, ничего не делает, если существует.



```
CREATE LOOKUP INDEX lookup_index_name FOR (n) ON EACH labels(n)
```
Создание маркерного поискового индекса с именем lookup_index_name на узлах с любой меткой .



```
CREATE LOOKUP INDEX FOR ()-[r]-() ON EACH type(r)
```
Создание маркерного поискового индекса для отношений с любым типом отношений.



```
CREATE FULLTEXT INDEX node_fulltext_index_name FOR (n:Friend) ON EACH [n.name]
OPTIONS {indexConfig: {`fulltext.analyzer`:'swedish'}}
```
Создаем полнотекстовый индекс на узлах с именем node_fulltext_index_name и анализатором swedish. Полнотекстовые индексы на узлах могут быть использованы только из процедуры db.index.fulltext.queryNodes. Остальные настройки индекса будут иметь значения по умолчанию.



```
CREATE FULLTEXT INDEX rel_fulltext_index_name FOR ()-[r:HAS_PET|BROUGHT_PET]-() ON EACH [r.since, r.price]
```
Создать полнотекстовый индекс по отношениям с именем rel_fulltext_index_name. Полнотекстовые индексы по отношениям могут быть использованы только из процедуры db.index.fulltext.queryRelationships.



```
ПОКАЗАТЬ ИНДЕКСЫ
```
Вывести список всех индексов.



```
MATCH (n:Person) WHERE n.name = $value
```
Для сравнения равенства может быть автоматически использован индекс. Обратите внимание, что в примере toLower(n.name) = $value индекс не будет использоваться.



```
MATCH (n:Person)
WHERE n.name IN [$value]
```
Для проверки списка IN автоматически может быть использован индекс.



```
MATCH (n:Person)
WHERE n.name = $value и n.age = $value2
```
Составной индекс может быть автоматически использован для сравнения равенства обоих свойств. Обратите внимание, что для использования составного индекса необходимо наличие предикатов для всех его свойств.



```
MATCH (n:Person)
USING INDEX n:Person(name)
WHERE n.name = $value
```
Использование индекса может быть принудительным, если Cypher использует неоптимальный индекс, или необходимо использовать более одного индекса.



```
DROP INDEX index_name
```
Удаляет индекс с именем index_name, выбрасывает ошибку, если индекс не существует.



```
DROP INDEX index_name IF EXISTS
```
Уничтожает индекс с именем index_name, если он существует, и ничего не делает, если он не существует.



### CONSTRAINT

```
CREATE CONSTRAINT ON (p:Person)
       ASSERT p.name IS UNIQUE
```
Создаем уникальное ограничение свойства на метку Person и свойство name. Если любой другой узел с такой меткой будет обновлен или создан с уже существующим именем, операция записи завершится неудачей. Это ограничение создаст сопутствующий индекс.



```
CREATE CONSTRAINT uniqueness ON (p:Person)
       ASSERT p.age IS UNIQUE
```
Создаем уникальное ограничение свойства на метку Person и свойство age с именем uniqueness. Если любой другой узел с этой меткой будет обновлен или создан с уже существующим возрастом, операция записи завершится неудачей. Это ограничение создаст сопутствующий индекс.



```
CREATE CONSTRAINT ON (p:Person)
       ASSERT p.surname IS UNIQUE
       OPTIONS {indexProvider: 'native-btree-1.0'}
```
Создайте ограничение уникального свойства на метку Person и свойство surname с поставщиком индекса native-btree-1.0 для сопутствующего индекса.



```
CREATE CONSTRAINT ON (p:Person)
       ASSERT p.name IS NOT NULL
```
(★) Создает ограничение существования свойства узла на метку Person и свойство name, выбрасывает ошибку, если ограничение уже существует. Если узел с этой меткой будет создан без имени или если свойство name будет удалено из существующего узла с меткой Person, операция записи завершится неудачей.



```
CREATE CONSTRAINT node_exists IF NOT EXISTS ON (p:Person)
       ASSERT p.name IS NOT NULL
```
(★) Если ограничение существования свойства узла на метке Person и имени свойства или любое ограничение с именем node_exists уже существует, то ничего не произойдет. Если такого ограничения не существует, то оно будет создано.



```
CREATE CONSTRAINT ON ()-[l:LIKED]-()
       ASSERT l.when IS NOT NULL
```
(★) Создайте ограничение на существование свойства отношения для типа LIKED и свойства when. Если отношение с этим типом будет создано без свойства when или если свойство when будет удалено из существующего отношения с типом LIKED, то операция записи завершится неудачей.



```
CREATE CONSTRAINT relationship_exists ON ()-[l:LIKED]-()
       ASSERT l.since IS NOT NULL
```
(★) Создайте ограничение существования свойства отношения для типа LIKED и свойства since с именем relationship_exists. Если будет создано отношение с этим типом без свойства since или если свойство since будет удалено из существующего отношения с типом LIKED, то операция записи завершится неудачей.



```
SHOW UNIQUE CONSTRAINTS YIELD *
```
Вывести список всех уникальных ограничений.



```
CREATE CONSTRAINT ON (p:Person)
      ASSERT (p.firstname, p.surname) IS NODE KEY
```
(★) Создайте ограничение узлового ключа на метку Person и свойства firstname и surname. Если узел с этой меткой будет создан без имени и фамилии, или если их комбинация не будет уникальной, или если метки имени и/или фамилии существующего узла с меткой Person будут изменены таким образом, чтобы нарушить эти ограничения, операция записи завершится неудачей.



```
CREATE CONSTRAINT node_key ON (p:Person)
      ASSERT (p.name, p.surname) IS NODE KEY
```
(★) Создайте ограничение node key на метку Person и свойства name и surname с именем node_key. Если узел с этой меткой будет создан без имени и фамилии, или если их комбинация не будет уникальной, или если метки имени и/или фамилии существующего узла с меткой Person будут изменены таким образом, чтобы нарушить эти ограничения, операция записи завершится неудачей.



```
CREATE CONSTRAINT node_key_with_config ON (p:Person)
      ASSERT (p.name, p.age) IS NODE KEY
      OPTIONS {indexConfig: {`spatial.wgs-84.min`: [-100.0, -100.0], `spatial.wgs-84.max`: [100.0, 100.0]}}
```
(★) Создайте узловое ключевое ограничение на метку Person и свойства name и age с именем node_key_with_config и заданными настройками spatial.wgs-84 для сопутствующего индекса. Остальные настройки индекса будут иметь значения по умолчанию.



```
DROP CONSTRAINT uniqueness
```
Удаляет ограничение с именем uniqueness, выбрасывает ошибку, если ограничение не существует.



```
DROP CONSTRAINT uniqueness IF EXISTS
```
Сбрасывает ограничение с именем uniqueness, если оно существует, ничего не делает, если не существует.



### Производительность

* По возможности используйте параметры вместо литералов. Это позволит Cypher повторно использовать ваши запросы вместо того, чтобы разбирать и строить новые планы выполнения.
* Всегда устанавливайте верхний предел для шаблонов переменной длины. Это может привести к тому, что запрос по ошибке затронет все узлы графа.
* Возвращайте только те данные, которые вам нужны. Избегайте возврата целых узлов и связей - вместо этого выбирайте нужные данные и возвращайте только их.
* Используйте `PROFILE` / `EXPLAIN` для анализа производительности запросов. Более подробная информация по этим и другим темам, например, подсказки планировщика, приведена в разделе [Query Tuning](https://neo4j.com/docs/cypher-manual/4.3/query-tuning).


Neo4j Multidatabase
-------------

### Управление базами данных

```
CREATE OR REPLACE DATABASE myDatabase
```
(★) Создание базы данных с именем myDatabase. Если база данных с таким именем уже существует, то существующая база данных удаляется и создается новая.



```
STOP DATABASE myDatabase
```
(★) Остановить базу данных myDatabase.



```
START DATABASE myDatabase
```
(★) Запуск базы данных myDatabase.



```
SHOW DATABASES
```
Выводит список всех баз данных в системе и информацию о них.



```
ПОКАЗАТЬ БАЗЫ ДАННЫХ
YIELD имя, текущий статус
WHERE name CONTAINS 'my' AND currentStatus = 'online'
```
Вывести список информации о базах данных, отфильтрованный по имени и текущему состоянию, а также уточненный по условиям.



```
SHOW DATABASE myDatabase
```
Вывести информацию о базе данных myDatabase.



```
ПОКАЗАТЬ БАЗУ ДАННЫХ ПО УМОЛЧАНИЮ
```
Вывод информации о базе данных по умолчанию.



```
SHOW HOME DATABASE
```
Выводит информацию о домашней базе данных текущего пользователя.



```
DROP DATABASE myDatabase IF EXISTS
```
(★) Удаление базы данных myDatabase, если она существует.



Безопасность Neo4j
--------

### Управление пользователями

```
CREATE USER alice SET PASSWORD $password
```
Создание нового пользователя и пароля. Этот пароль должен быть изменен при первом входе в систему.



```
ALTER USER alice SET PASSWORD $password CHANGE NOT REQUIRED
```
Установить новый пароль для пользователя. При следующем входе в систему пользователю не потребуется менять этот пароль.



```
ALTER USER alice IF EXISTS SET PASSWORD CHANGE REQUIRED
```
Если указанный пользователь существует, то при следующем входе в систему он должен сменить свой пароль.



```
ALTER USER alice SET STATUS SUSPENDED
```
(★) Изменение статуса пользователя на приостановленный. Для возобновления работы пользователя используйте команду SET STATUS ACTIVE.



```
ALTER USER alice SET HOME DATABASE otherDb
```
(★) Изменение домашней базы данных пользователя на otherDb. Чтобы снять установку домашней базы данных для пользователя и вернуться к базе данных по умолчанию, используйте команду REMOVE HOME DATABASE.



```
ALTER CURRENT USER SET PASSWORD FROM $old TO $new
```
Изменение пароля вошедшего в систему пользователя. При следующем входе в систему пользователю не потребуется менять этот пароль.



```
ПОКАЗАТЬ ТЕКУЩЕГО ПОЛЬЗОВАТЕЛЯ
```
Выводит список пользователей, вошедших в систему в данный момент, их статус, роли и необходимость смены пароля.
(★) Статус и роли указаны только в версии Enterprise Edition.



```
ПОКАЗАТЬ ПОЛЬЗОВАТЕЛЕЙ
```
Выводит список всех пользователей в системе, их статус, роли и необходимость смены пароля.
(★) Статус и роли указаны только в версии Enterprise Edition.



```
ПОКАЗАТЬ ПОЛЬЗОВАТЕЛЕЙ
YIELD user, suspended
WHERE suspended = true
```
Список пользователей в системе, отфильтрованных по имени и статусу и уточненных по наличию приостановленных пользователей.
(★) Статус указывается только в версии Enterprise Edition.



```
Переименование пользователя alice в alice_delete
```
Переименование пользователя alice в alice_delete.



```
DROP USER alice_delete
```
Удалить пользователя.



### (★) Управление ролями

```
CREATE ROLE my_role
```
Создать роль.



```
CREATE ROLE my_second_role IF NOT EXISTS AS COPY OF my_role
```
Создать роль с именем my_second_role, если она еще не существует, как копию существующей my_role.



```
RENAME ROLE my_second_role TO my_other_role
```
Переименование роли с именем my_second_role в my_other_role.



```
GRANT ROLE my_role, my_other_role TO alice
```
Назначение ролей пользователю.



```
REVOKE ROLE my_other_role FROM alice
```
Удалить указанную роль из пользователя.



```
ПОКАЗАТЬ РОЛИ
```
Выводит список всех ролей в системе.



```
ПОКАЗАТЬ РОЛИ
YIELD role
WHERE role CONTAINS 'my'
```
Список ролей, отфильтрованный по имени роли и уточненный по наличию в имени роли слова 'my'.



```
ПОКАЗАТЬ ЗАПОЛНЕННЫЕ РОЛИ С ПОЛЬЗОВАТЕЛЯМИ
```
Выводит список всех ролей, которые назначены хотя бы одному пользователю в системе, и пользователей, назначенных на эти роли.



```
DROP ROLE my_role
```
Удалить роль.



### (★) Графические привилегии на чтение

```
GRANT TRAVERSE ON GRAPH * NODES * TO my_role
```
Предоставляет роли привилегию обхода всех узлов и всех графов.



```
DENY READ {prop} ON GRAPH foo RELATIONSHIP Type TO my_role
```
Запрещает привилегию чтения указанного свойства, всех отношений с указанным типом в указанном графе, для роли.



```
GRANT MATCH {*} ON HOME GRAPH ELEMENTS Label TO my_role
```
Предоставляет роли привилегию чтения всех свойств и привилегию обхода в домашнем графе. Здесь обе привилегии применяются ко всем узлам и связям с указанной меткой/типом в графе.



### (★) Привилегии записи в граф

```
GRANT CREATE ON GRAPH * NODES Label TO my_role
```
Предоставляет роли привилегию create на все узлы с указанной меткой во всех графах.



```
DENY DELETE ON GRAPH neo4j TO my_role
```
Запрещает удаление всех узлов и связей в указанном графе для роли.



```
REVOKE SET LABEL Label ON GRAPH * FROM my_role
```
Отменяет привилегию set label для указанной метки на всех графиках для роли.



```
GRANT REMOVE LABEL * ON GRAPH foo TO my_role
```
Предоставление роли привилегии удаления меток для всех меток на указанном графе.



```
DENY SET PROPERTY {prop} ON GRAPH foo RELATIONSHIPS Type TO my_role
```
Запрещает роли устанавливать привилегию на указанное свойство, на все отношения с указанным типом в указанном графе.



```
GRANT MERGE {*} ON GRAPH * NODES Label TO my_role
```
Предоставляет роли привилегию слияния на все свойства, на все узлы с указанной меткой во всех графах.



```
REVOKE WRITE ON GRAPH * FROM my_role
```
Отмена права записи на все графы от роли.



```
DENY ALL GRAPH PRIVILEGES ON GRAPH foo TO my_role
```
Запретить роли все привилегии графа на указанном графе.



### (★) ПОКАЗАТЬ ПРИВИЛЕГИИ

```
ПОКАЗАТЬ ПРИВИЛЕГИИ В ВИДЕ КОМАНД
```
Выводит список всех привилегий в системе в виде команд Cypher.



```
ПОКАЗАТЬ ПРИВИЛЕГИИ
```
Выводит список всех привилегий в системе и ролей, которым они назначены.



```
ПОКАЗАТЬ ПРИВИЛЕГИИ
YIELD роль, действие, доступ
WHERE role = 'my_role'
```
Список информации о привилегиях, отфильтрованный по роли, действию и доступу и уточненный по имени роли.



```
SHOW ROLE my_role PRIVILEGES AS COMMANDS
```
Перечислить все привилегии, назначенные роли в виде команд Cypher.



```
SHOW ROLE my_role, my_second_role PRIVILEGES AS COMMANDS
```
Перечислите все привилегии, назначенные каждой из нескольких ролей, в виде команд Cypher.



```
SHOW USER alice PRIVILEGES AS COMMANDS
```
Перечислить все привилегии пользователя и роли, которым они назначены, в виде команд Cypher.



```
ПОКАЗАТЬ ПРИВИЛЕГИИ ПОЛЬЗОВАТЕЛЯ В ВИДЕ КОМАНД
```
Выводит список всех привилегий текущего вошедшего в систему пользователя и роли, которой они назначены, в виде команд Cypher.



### (★) Привилегии базы данных

```
GRANT ACCESS ON DATABASE * TO my_role
```
Предоставление роли привилегий на доступ и выполнение запросов ко всем базам данных.



```
GRANT START ON DATABASE * TO my_role
```
Предоставление привилегии на запуск всех баз данных роли.



```
GRANT STOP ON DATABASE * TO my_role
```
Предоставление привилегии на остановку всех баз данных роли.



```
GRANT CREATE INDEX ON DATABASE foo TO my_role
```
Предоставление роли привилегии на создание индексов в указанной базе данных.



```
GRANT DROP INDEX ON DATABASE foo TO my_role
```
Предоставление роли привилегии на сброс индексов в указанной базе данных.



```
GRANT SHOW INDEX ON DATABASE * TO my_role
```
Предоставление роли привилегии на показ индексов во всех базах данных.



```
DENY INDEX MANAGEMENT ON DATABASE bar TO my_role
```
Запрещает привилегии на создание и удаление индексов в указанной базе данных для роли.



```
GRANT CREATE CONSTRAINT ON DATABASE * TO my_role
```
Предоставление роли привилегии на создание ограничений для всех баз данных.



```
DENY DROP CONSTRAINT ON DATABASE * TO my_role
```
Запрет привилегии на сброс ограничений на все базы данных для роли.



```
DENY SHOW CONSTRAINT ON DATABASE foo TO my_role
```
Запрет привилегии на показ ограничений на указанную базу данных для роли.



```
REVOKE CONSTRAINT ON DATABASE * FROM my_role
```
Отменяет предоставленные и запрещенные привилегии на создание и сброс ограничений на все базы данных от роли.



```
GRANT CREATE NEW LABELS ON DATABASE * TO my_role
```
Предоставление роли привилегии на создание новых меток во всех базах данных.



```
DENY CREATE NEW TYPES ON DATABASE foo TO my_role
```
Запрещает привилегию создания новых типов отношений на указанной базе данных для роли.



```
REVOKE GRANT CREATE NEW PROPERTY NAMES ON DATABASE bar FROM my_role
```
Отменяет привилегию grant на создание новых имен свойств в указанной базе данных от роли.



```
GRANT NAME MANAGEMENT ON HOME DATABASE TO my_role
```
Предоставление роли привилегий на создание меток, типов отношений и имен свойств в домашней базе данных.



```
GRANT ALL ON DATABASE baz TO my_role
```
Предоставление роли привилегий на доступ, создание и удаление индексов и ограничений, создание новых меток, типов и имен свойств в указанной базе данных.



```
GRANT SHOW TRANSACTION (*) ON DATABASE foo TO my_role
```
Предоставление роли привилегии на список транзакций и запросов всех пользователей указанной базы данных.



```
DENY TERMINATE TRANSACTION (user1, user2) ON DATABASES * TO my_role
```
Запрет привилегии на уничтожение транзакций и запросов от пользователей user1 и user2 на всех базах данных для роли.



```
REVOKE GRANT TRANSACTION MANAGEMENT ON HOME DATABASE FROM my_role
```
Отмена предоставленной привилегии на перечисление и уничтожение транзакций и запросов от всех пользователей домашней базы данных от роли.



### (★) Привилегии управления ролями

```
GRANT CREATE ROLE ON DBMS TO my_role
```
Предоставляет привилегию на создание ролей для роли.



```
GRANT RENAME ROLE ON DBMS TO my_role
```
Предоставление привилегии переименования ролей роли.



```
GRANT DROP ROLE ON DBMS TO my_role
```
Предоставление привилегии на удаление ролей роли.



```
DENY ASSIGN ROLE ON DBMS TO my_role
```
Запретить привилегию назначения ролей пользователям на роль.



```
DENY REMOVE ROLE ON DBMS TO my_role
```
Запрещает привилегию удаления ролей от пользователей к роли.



```
REVOKE DENY SHOW ROLE ON DBMS FROM my_role
```
Отмена запрещенной привилегии на показ ролей из роли.



```
GRANT ROLE MANAGEMENT ON DBMS TO my_role
```
Предоставление всех привилегий по управлению ролями роли.



### (★) Привилегии управления пользователями

```
GRANT CREATE USER ON DBMS TO my_role
```
Предоставление привилегии на создание пользователей роли.



```
GRANT RENAME USER ON DBMS TO my_role
```
Предоставление привилегии переименования пользователей роли.



```
DENY ALTER USER ON DBMS TO my_role
```
Запрет на изменение пользователей в роли.



```
REVOKE SET PASSWORDS ON DBMS FROM my_role
```
Отменяет предоставленные и запрещенные привилегии на изменение паролей пользователей от роли.



```
REVOKE GRANT SET USER STATUS ON DBMS FROM my_role
```
Отменяет предоставленную привилегию на изменение состояния учетной записи пользователей из роли.



```
GRANT SET USER HOME DATABASE ON DBMS TO my_role
```
Предоставление привилегии изменения домашней базы данных пользователей роли.



```
GRANT DROP USER ON DBMS TO my_role
```
Предоставление привилегии на удаление пользователей роли.



```
REVOKE DENY SHOW USER ON DBMS FROM my_role
```
Отозвать запрещенную привилегию на показ пользователей из роли.



```
GRANT USER MANAGEMENT ON DBMS TO my_role
```
Предоставление всех привилегий по управлению пользователями роли.



### (★) Привилегии управления базами данных

```
GRANT CREATE DATABASE ON DBMS TO my_role
```
Предоставление привилегии на создание баз данных роли.



```
REVOKE DENY DROP DATABASE ON DBMS FROM my_role
```
Отозвать у роли запрещенную привилегию на удаление баз данных.



```
DENY DATABASE MANAGEMENT ON DBMS TO my_role
```
Запрещает все привилегии по управлению базой данных для роли.



### (★) Привилегии управления привилегиями

```
GRANT SHOW PRIVILEGE ON DBMS TO my_role
```
Предоставляет привилегию показывать привилегии роли.



```
DENY ASSIGN PRIVILEGE ON DBMS TO my_role
```
Запрет на назначение привилегий ролям для роли.



```
REVOKE GRANT REMOVE PRIVILEGE ON DBMS FROM my_role
```
Отменяет предоставленную привилегию на удаление привилегий из ролей из роли.



```
REVOKE PRIVILEGE MANAGEMENT ON DBMS FROM my_role
```
Отменяет все предоставленные и запрещенные привилегии для привилегий управления от роли.



### (★) Привилегии СУБД

```
GRANT ALL ON DBMS TO my_role
```
Предоставляет привилегии на выполнение всех действий по управлению ролями, пользователями, базами данных и привилегиями для роли.



★ Примечание
----

(★) Функциональные возможности, доступные в Neo4j Enterprise Edition.
